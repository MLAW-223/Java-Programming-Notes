# Java Getters and Setters

## Introduction to Getters and Setters
Getters and setters are fundamental concepts in Java object-oriented programming. They serve two primary purposes:

**Data Protection:** They help protect an object's internal data (fields or attributes) from unauthorized or unintended modifications.

**Controlled Access:** They provide controlled access to an object's data, allowing you to implement specific rules or logic when reading or writing the data.

**Key Concepts:**
- **Getter Methods:** These methods are used to read the value of a private field. They are often referred to as "accessor" methods.
- **Setter Methods:** These methods are used to write or modify the value of a private field. They are often referred to as "mutator" methods.

## Encapsulation and Access Modifiers
Getters and setters are closely tied to the principle of encapsulation, a core OOP concept. Encapsulation involves bundling data (fields) and the methods that operate on that data within a single unit (a class).

**The private Access Modifier**
To effectively use getters and setters, you must declare your class fields using the `private` access modifier. This restricts direct access to these fields from outside the class.

**Example:**
```java
public class Car {
    private String model;
    private String color;
    private int price;

    // Constructor and methods will go here
}
```

If fields are declared as `private`, you cannot directly access or modify them like this:
```java
Car myCar = new Car("Charger", "Yellow", 10000);
// This will cause a compile-time error:
// System.out.println(myCar.color);
// myCar.price = -5000;
```

## Implementing Getter Methods
Getter methods provide read access to private fields. They typically follow a naming convention of `getFieldName()`.

**General Structure:**
```java
public ReturnType getFieldName() {
    return this.fieldName;
}
```

**Example Getters for the Car class:**
```java
public class Car {
    private String model;
    private String color;
    private int price;

    // Constructor
    Car(String model, String color, int price){
        this.model = model;
        this.color = color;
        this.price = price;
    }

    // Getter for model
    String getModel(){
        return this.model;
    }

    // Getter for color
    String getColor(){
        return this.color;
    }

    // Getter for price (with added formatting)
    String getPrice(){
        return "$" + this.price;
    }

    // Setter methods will go here
}
```

**Calling Getter Methods:**
You call getter methods on an object to retrieve the value of its private fields.
```java
Car myCar = new Car("Charger", "Yellow", 10000);

System.out.println(myCar.getColor()); // Output: Yellow
System.out.println(myCar.getModel()); // Output: Charger
System.out.println(myCar.getPrice()); // Output: $10000
```

**Note:** The `getPrice()` method in the example demonstrates how you can add logic within a getter. Here, it prepends a dollar sign to the price for display purposes.

## Implementing Setter Methods
Setter methods provide write access to private fields. They typically follow a naming convention of `setFieldName(DataType parameterName)`.

**General Structure:**
```java
public void setFieldName(DataType parameterName) {
    this.fieldName = parameterName;
}
```

**Example Setters for the Car class:**
```java
public class Car {
    private String model;
    private String color;
    private int price;

    // Constructor
    Car(String model, String color, int price){
        this.model = model;
        this.color = color;
        this.price = price;
    }

    // Getter methods (as shown previously)
    String getModel(){ return this.model; }
    String getColor(){ return this.color; }
    String getPrice(){ return "$" + this.price; }

    // Setter for color
    void setColor(String color){
        this.color = color;
    }

    // Setter for price (with validation logic)
    void setPrice(int price){
        if(price < 0) {
            System.out.println("Price cannot be less than zero.");
        } else {
            this.price = price;
        }
    }
}
```

**Calling Setter Methods:**
You call setter methods on an object to change the value of its private fields.
```java
Car myCar = new Car("Charger", "Yellow", 10000);

myCar.setColor("Blue"); // Changes the color to "Blue"
myCar.setPrice(5000);   // Changes the price to 5000

System.out.println(myCar.getColor()); // Output: Blue
System.out.println(myCar.getPrice()); // Output: $5000

myCar.setPrice(-100);   // Output: Price cannot be less than zero.
System.out.println(myCar.getPrice()); // Output: $5000 (price remains unchanged)
```

**Note:** The `setPrice()` method includes validation logic. It checks if the provided price is non-negative before updating the price field. This is a key benefit of using setters – enforcing business rules.

## Making Fields Read-Only or Write-Only
You have flexibility in deciding which fields should be readable, writable, or both.

**Read-Only Field:** Provide only a getter method and do not provide a setter method. To make a field truly immutable (unchangeable after initialization), you can also declare it with the `final` keyword.
```java
public class Product {
    private final String id; // Read-only and immutable
    private String name;

    Product(String id, String name) {
        this.id = id;
        this.name = name;
    }

    public String getId() { // Getter exists
        return id;
    }

    // No setter for id
    // public void setId(String id) { this.id = id; } // This would cause a compile error if uncommented

    public String getName() {
        return name;
    }

    public void setName(String name) { // Setter exists
        this.name = name;
    }
}
```

**Write-Only Field:** Provide only a setter method and no getter. This is less common but can be useful in specific scenarios where you only want to modify a value without exposing its current state directly.

**Both Readable and Writable:** Provide both a getter and a setter method. This is the most common scenario.

## Summary of Benefits
Using getters and setters (encapsulation) offers several advantages:

**Control:** You control how fields are accessed and modified, allowing you to add validation, logging, or other logic.

**Flexibility:** You can change the internal implementation of a class (e.g., how data is stored) without affecting the code that uses the class, as long as the getter and setter signatures remain the same.

**Maintainability:** Code becomes easier to understand and maintain because access to data is centralized through well-defined methods.

**Security:** Prevents accidental modification of data, improving the robustness of your application.

---

## Activities

### Activity 1: Bank Account Class
Create a `BankAccount` class with private fields: `accountNumber`, `accountHolder`, and `balance`. Implement appropriate getters and setters with the following rules:
- `accountNumber` should be read-only (set only in constructor)
- `accountHolder` should be readable and writable
- `balance` should have a getter, but only allow deposits and withdrawals through specific methods (`deposit()` and `withdraw()`) that include validation (no negative deposits, no withdrawals exceeding balance)

### Activity 2: Student Grade System
Create a `Student` class with private fields: `name`, `studentId`, and `grades` (an array or list of integers). Implement getters and setters with validation:
- `name` should not be empty or null
- `studentId` should be read-only and exactly 6 characters
- `grades` should only accept values between 0 and 100
- Add a method `getAverageGrade()` that calculates and returns the average of all grades

### Activity 3: Temperature Converter
Create a `Temperature` class with a private field `celsius`. Implement getters and setters for both Celsius and Fahrenheit values:
- `getCelsius()` returns the temperature in Celsius
- `setCelsius(double value)` sets the temperature in Celsius
- `getFahrenheit()` converts and returns the temperature in Fahrenheit
- `setFahrenheit(double value)` accepts Fahrenheit and converts it to Celsius for storage
- Add validation to reject temperatures below absolute zero (-273.15°C or -459.67°F)
