# Java Anonymous Classes

## What are Anonymous Classes?
Anonymous classes are a way to create classes without explicitly naming them. They are essentially classes that are defined and instantiated at the same time.

**No Name:** They do not have a formal class name.

**Cannot be Reused:** Because they lack a name, they cannot be instantiated multiple times or extended by other classes.

**Custom Behavior:** They are used to add custom behavior to an object without the overhead of creating a separate, named class file. This is particularly useful when you need a specific behavior for a single instance of an object.

**Common Use Cases:** Anonymous classes are frequently used in situations like:
- Implementing `Runnable` interfaces for threads.
- Handling events (callbacks).
- Working with `TimerTask` for scheduled tasks.

## Why Use Anonymous Classes?
Creating a new, named class for every unique object or behavior can be cumbersome and lead to a large number of small, single-purpose classes. Anonymous classes provide a more concise way to achieve this customization.

Consider a `Dog` class with a `speak()` method:

```java
public class Dog {
    void speak() {
        System.out.println("The dog goes *woof*");
    }
}
```

If you want a specific dog, like "Scooby-Doo," to speak differently, you have two main approaches:

**Creating a New Named Class (Less Efficient for One-Time Use):**
You could create a new class, `TalkingDog`, that extends `Dog` and overrides the `speak()` method.
This involves creating a new `.java` file and writing more code, which can be excessive if you only need one such "talking dog."

```java
// In a separate file: TalkingDog.java
public class TalkingDog extends Dog {
    @Override
    void speak() {
        System.out.println("Scooby Doo says *Ruh Roh*");
    }
}

// In Main.java
public class Main {
    public static void main(String[] args) {
        TalkingDog scooby = new TalkingDog();
        scooby.speak(); // Output: Scooby Doo says *Ruh Roh*
    }
}
```

**Using an Anonymous Class (More Concise for One-Time Use):**
You can create an instance of `Dog` and, at the same time, provide a custom implementation for its `speak()` method.

```java
public class Main {
    public static void main(String[] args) {
        Dog scooby = new Dog() { // Anonymous class starts here
            @Override
            void speak() {
                System.out.println("Scooby Doo says *Ruh Roh*");
            }
        }; // Anonymous class ends here
        scooby.speak(); // Output: Scooby Doo says *Ruh Roh*
    }
}
```

This approach avoids creating a separate `TalkingDog` class file and keeps the custom behavior localized to where it's used.

## Syntax of Anonymous Classes
An anonymous class is defined inline, typically when you are creating an instance of a class or implementing an interface.

**General Syntax:**

```java
// When extending a class
new ClassName(arguments) {
    // Anonymous class body
    // Override methods or add new methods/fields
}

// When implementing an interface
new InterfaceName() {
    // Anonymous class body
    // Implement interface methods
}
```

**Key points about the syntax:**
- You start with the `new` keyword followed by the name of the class you are extending or the interface you are implementing.
- If the parent class has a constructor that requires arguments, you provide them within the parentheses `()` after the class name.
- You then immediately follow with a set of curly braces `{}`. This block contains the body of the anonymous class.
- Inside the curly braces, you can override methods from the parent class or implement methods from the interface. You can also declare new fields and methods, though this is less common for typical use cases like `Runnable`.
- Crucially, the anonymous class definition must end with a semicolon `;` because it's treated as an expression.

## Example: Anonymous Class with a Runnable Interface
Anonymous classes are very common when working with threads using the `Runnable` interface.

```java
public class Main {
    public static void main(String[] args) {
        // Create a new thread using an anonymous Runnable
        Thread myThread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("This code is running in a separate thread!");
                // You can add any logic here for the thread's execution
            }
        });

        myThread.start(); // Start the thread
    }
}
```

In this example:
- We are creating a `Thread` object. The `Thread` constructor can accept a `Runnable` object.
- Instead of creating a separate class that implements `Runnable`, we create an anonymous class that implements `Runnable` directly.
- The `run()` method of the `Runnable` interface is overridden within the anonymous class body to define the task the thread will perform.
- `myThread.start()` executes the `run()` method in a new thread.

## Limitations of Anonymous Classes
**No Reusability:** As mentioned, their primary limitation is that they cannot be reused. Each time you need a similar custom behavior, you have to define a new anonymous class.

**Limited Scope:** They are best suited for short, specific pieces of code. For complex or reusable logic, a named class is a better choice.

**No Constructors:** Anonymous classes cannot have constructors. If you need to initialize fields, you can do so directly within the anonymous class body or use an initializer block.

**Cannot be Extended:** You cannot create another class that extends an anonymous class.

## When to Choose Anonymous Classes
When you need to override just one or a few methods of a superclass or implement an interface for a single, specific purpose.

When the code is short and self-contained.

When creating objects for frameworks that expect implementations of interfaces or subclasses (e.g., event listeners, callbacks, `Runnable`).

If you find yourself defining the same anonymous class multiple times, or if the logic within the anonymous class becomes extensive, it's a strong indicator that you should refactor it into a separate, named class.

---

## Activities

### Activity 1: Anonymous Animal Creator
Create an abstract `Animal` class with an abstract `makeSound()` method. In the main method:
1. Create a regular `Dog` class that extends `Animal`
2. Use an anonymous class to create a `Cat` with a custom sound
3. Use another anonymous class to create a `Bird` with a custom sound
4. Store all animals in an ArrayList and call `makeSound()` on each

### Activity 2: Event Handler Simulation
Create an interface `ClickListener` with a method `onClick(String buttonName)`. In the main method:
1. Create three different buttons ("Save", "Delete", "Cancel")
2. Use anonymous classes to create different click handlers for each button
3. Simulate clicking each button and display appropriate messages for each

### Activity 3: Thread Task Manager
Create a program that:
1. Uses anonymous `Runnable` classes to create three different tasks
2. Each task should print a different message with its thread ID
3. Start all threads simultaneously and observe the output
4. Modify one task to count from 1 to 5 with 1-second delays between numbers
