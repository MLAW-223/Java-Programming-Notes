# The static Keyword in Java

## Introduction to `static`
The `static` keyword in Java is a modifier that can be applied to variables, methods, and even nested classes. When `static` is used, it signifies that the member (variable or method) belongs to the class itself rather than to any specific instance (object) of that class.

This means:
- A **static variable** is shared among all objects of the class. There's only one copy of the static variable, regardless of how many objects are created.
- A **static method** can be called directly on the class name without needing to create an object. Static methods can only directly access other static members (variables or methods) of the same class. They cannot directly access instance variables or instance methods because they are not associated with a specific object.

## Common Use Cases for `static`
- **Utility Methods:** Methods that perform a general operation and don't rely on the state of a specific object (e.g., `Math.round()`).
- **Shared Resources:** Variables that need to be accessed and modified by all instances of a class, such as counters, constants, or connection pools.

## `static` Variables (Fields)
A static variable, also known as a class variable, is declared using the `static` keyword.

### How `static` Variables Work
When you declare a static variable, it is initialized only once when the class is loaded into memory. All objects created from this class will share this single copy of the variable.

### Example: Tracking the Number of Friends
Consider a `Friend` class where we want to keep track of the total number of Friend objects created.

```java
public class Friend {
    // static variable shared by all Friend objects
    static int numOfFriends = 0;
    String name;

    Friend(String name) {
        this.name = name;
        // Increment the shared static variable
        numOfFriends++;
    }

    // Other methods...
}
```

In the Main class:

```java
public class Main {
    public static void main(String[] args) {
        Friend friend1 = new Friend("Spongebob");
        Friend friend2 = new Friend("Patrick");
        Friend friend3 = new Friend("Squidward");

        // Accessing the static variable through the class name
        System.out.println("Total friends: " + Friend.numOfFriends); // Output: Total friends: 3
    }
}
```

**Explanation:**
- `numOfFriends` is declared as `static int`. This means there is only one `numOfFriends` variable for the entire `Friend` class.
- Each time a new `Friend` object is created (`new Friend(...)`), the constructor is called, and `numOfFriends` is incremented.
- Even though `friend1`, `friend2`, and `friend3` are separate objects, they all refer to the same `numOfFriends` variable.
- It is best practice to access static variables using the class name (e.g., `Friend.numOfFriends`) for clarity, rather than through an object instance (e.g., `friend1.numOfFriends`), although the latter might work in some cases.

## `static` Methods
A static method is declared using the `static` keyword.

### How `static` Methods Work
- Static methods belong to the class itself, not to any particular object.
- They can be called directly using the class name (e.g., `ClassName.staticMethodName()`).
- Static methods can only directly access other static members (variables or methods) of the same class. They cannot access instance variables or instance methods because they don't operate on a specific object's state.
- Inside a static method, you cannot use the `this` keyword, as `this` refers to the current object instance, which doesn't exist in the context of a static method.

### Example: Displaying the Number of Friends
Let's add a static method to our `Friend` class to display the total number of friends.

```java
public class Friend {
    static int numOfFriends = 0;
    String name;

    Friend(String name) {
        this.name = name;
        numOfFriends++;
    }

    // static method to display the total number of friends
    static void showFriends() {
        System.out.println("You have " + numOfFriends + " total friends");
    }
}
```

In the Main class:

```java
public class Main {
    public static void main(String[] args) {
        Friend friend1 = new Friend("Spongebob");
        Friend friend2 = new Friend("Patrick");
        Friend friend3 = new Friend("Squidward");
        Friend friend4 = new Friend("Sandy");

        // Calling the static method directly on the class
        Friend.showFriends(); // Output: You have 4 total friends

        Friend friend5 = new Friend("Gary");
        Friend.showFriends(); // Output: You have 5 total friends
    }
}
```

**Explanation:**
- The `showFriends()` method is declared as `static`.
- It can access the static variable `numOfFriends` directly because both are members of the same class and are static.
- The method is called using `Friend.showFriends()`. We don't need to create a `Friend` object to call this method.

## `static` Methods as Utility Functions (e.g., Math class)
The `Math` class in Java is a prime example of using static methods for utility purposes.

```java
public class MathExample {
    public static void main(String[] args) {
        double numberToRound = 4.7;

        // Calling a static method from the Math class
        long roundedNumber = Math.round(numberToRound);

        System.out.println("Original number: " + numberToRound);
        System.out.println("Rounded number: " + roundedNumber);
        // Output:
        // Original number: 4.7
        // Rounded number: 5
    }
}
```

**Explanation:**
- The `Math.round()` method is static. You don't need to create an instance of the Math class (`new Math()`) to use it.
- You call it directly using the class name: `Math.round()`. This makes utility functions easily accessible.

## Key Takeaways
- `static` members (variables and methods) belong to the class, not to individual objects.
- `static` variables are shared among all instances of a class.
- `static` methods can be called without creating an object and can only directly access other static members.
- Use `static` for utility functions and shared resources to improve code organization and efficiency.
- Access static members using the class name (e.g., `ClassName.staticMember`) for clarity.

## Types of `static` Members

### 1. Static Variables (Class Variables)
```java
public class Company {
    static String companyName = "TechCorp"; // Shared by all employees
    String employeeName;
    
    public Company(String employeeName) {
        this.employeeName = employeeName;
    }
}
```

### 2. Static Methods
```java
public class Calculator {
    public static int add(int a, int b) {
        return a + b;
    }
    
    public static double calculateArea(double radius) {
        return Math.PI * radius * radius;
    }
}
```

### 3. Static Blocks
```java
public class DatabaseConnection {
    static String connectionString;
    
    // Static initialization block
    static {
        // This runs when the class is loaded
        connectionString = "jdbc:mysql://localhost:3306/mydb";
        System.out.println("Database connection initialized");
    }
}
```

### 4. Static Nested Classes
```java
public class OuterClass {
    static class StaticNestedClass {
        void display() {
            System.out.println("Inside static nested class");
        }
    }
}
```

## Rules and Restrictions

### 1. Accessing Non-Static Members from Static Context
```java
public class Example {
    int instanceVariable = 10;
    static int staticVariable = 20;
    
    void instanceMethod() {
        System.out.println("Instance method");
    }
    
    static void staticMethod() {
        // Can access static members
        System.out.println(staticVariable); // OK
        
        // Cannot access instance members directly
        // System.out.println(instanceVariable); // ERROR
        // instanceMethod(); // ERROR
        
        // Must create an instance first
        Example obj = new Example();
        System.out.println(obj.instanceVariable); // OK
        obj.instanceMethod(); // OK
    }
}
```

### 2. The `main` Method
```java
public class MainClass {
    // The main method must be static
    public static void main(String[] args) {
        // Entry point of the program
    }
}
```

## Best Practices for Using `static`

### 1. Constants
```java
public class Constants {
    // Use public static final for constants
    public static final double PI = 3.14159;
    public static final int MAX_USERS = 1000;
    public static final String APP_NAME = "MyApplication";
}
```

### 2. Factory Methods
```java
public class DateUtil {
    // Static factory method
    public static Date createDate(int year, int month, int day) {
        Calendar calendar = Calendar.getInstance();
        calendar.set(year, month, day);
        return calendar.getTime();
    }
}
```

### 3. Utility Classes
```java
// Final class with private constructor to prevent instantiation
public final class StringUtils {
    // Private constructor to prevent instantiation
    private StringUtils() {
        throw new AssertionError("Cannot instantiate utility class");
    }
    
    public static boolean isEmpty(String str) {
        return str == null || str.trim().isEmpty();
    }
    
    public static String reverse(String str) {
        if (isEmpty(str)) return str;
        return new StringBuilder(str).reverse().toString();
    }
}
```

## Common Pitfalls

### 1. Thread Safety Issues
```java
public class Counter {
    static int count = 0; // Not thread-safe
    
    // Synchronize for thread safety
    public static synchronized void increment() {
        count++;
    }
}
```

### 2. Memory Leaks
```java
public class Cache {
    static Map<String, Object> cache = new HashMap<>();
    
    // Objects stored in static collections may not be garbage collected
    public static void addToCache(String key, Object value) {
        cache.put(key, value);
    }
    
    // Provide cleanup method
    public static void removeFromCache(String key) {
        cache.remove(key);
    }
}
```

### 3. Testing Difficulties
```java
public class Config {
    static String apiKey = "default_key"; // Hard to mock in tests
    
    // Better approach: use dependency injection
    private static String apiKey;
    
    public static void setApiKey(String key) {
        apiKey = key;
    }
}
```

## Real-World Examples

### Example 1: Singleton Pattern
```java
public class DatabaseManager {
    // Static instance for singleton
    private static DatabaseManager instance;
    
    private DatabaseManager() {
        // Private constructor
    }
    
    // Static method to get instance
    public static DatabaseManager getInstance() {
        if (instance == null) {
            instance = new DatabaseManager();
        }
        return instance;
    }
}
```

### Example 2: Logger Class
```java
public class Logger {
    private static Logger instance;
    private static final String LOG_FILE = "app.log";
    
    private Logger() {
        // Initialize logger
    }
    
    public static Logger getLogger() {
        if (instance == null) {
            instance = new Logger();
        }
        return instance;
    }
    
    public static void log(String message) {
        System.out.println("[LOG] " + new Date() + ": " + message);
    }
}
```

### Example 3: Configuration Management
```java
public class ConfigManager {
    private static Properties properties;
    
    static {
        properties = new Properties();
        try {
            properties.load(new FileInputStream("config.properties"));
        } catch (IOException e) {
            System.err.println("Failed to load configuration");
        }
    }
    
    public static String getProperty(String key) {
        return properties.getProperty(key);
    }
    
    public static int getIntProperty(String key, int defaultValue) {
        String value = properties.getProperty(key);
        return value != null ? Integer.parseInt(value) : defaultValue;
    }
}
```

## Performance Considerations

### 1. Static Variable Initialization
```java
public class PerformanceExample {
    // Static variables are initialized once when class is loaded
    static ExpensiveObject expensiveObject = new ExpensiveObject();
    
    // Better: lazy initialization
    private static ExpensiveObject lazyObject;
    
    public static ExpensiveObject getLazyObject() {
        if (lazyObject == null) {
            lazyObject = new ExpensiveObject();
        }
        return lazyObject;
    }
}
```

### 2. Static vs Instance Method Performance
```java
// Static methods are slightly faster as they don't require object creation
// But the difference is usually negligible
```

---

## Activities

### Activity 1: Bank Account System with Static Members
Create a `BankAccount` class with:
1. **Static variables:** totalAccounts (counter), bankName, interestRate
2. **Instance variables:** accountNumber, accountHolder, balance
3. **Static methods:**
   - `getTotalAccounts()`: Returns total number of accounts created
   - `getBankInfo()`: Returns bank information
   - `updateInterestRate(newRate)`: Updates interest rate for all accounts
4. **Instance methods:** deposit(), withdraw(), calculateInterest()
5. Test by creating multiple accounts and calling static methods

### Activity 2: Shopping Cart with Static Counter
Create a `ShoppingCart` class with:
1. **Static variable:** totalCartsCreated
2. **Instance variables:** cartId, items (array/list), totalAmount
3. **Static method:** `getTotalCartsCreated()`
4. **Instance methods:** addItem(), removeItem(), calculateTotal()
5. Each cart should have a unique ID based on totalCartsCreated
6. Create multiple carts and track the total number created

### Activity 3: Student Grading System with Static Utilities
Create a `StudentGrades` system with:
1. **Static utility class** `GradeCalculator` with methods:
   - `calculateAverage(double[] grades)`
   - `calculateStandardDeviation(double[] grades)`
   - `convertToLetterGrade(double percentage)`
   - `findHighestGrade(double[] grades)`
   - `findLowestGrade(double[] grades)`
2. **Student class** with instance variables: name, studentId, grades[]
3. **Static variable** in Student class: totalStudents
4. Test the system with multiple students and use static utility methods
