# Java Generics

## Introduction to Generics
Generics in Java provide a way to write classes, interfaces, and methods that are compatible with different data types. This allows for code reusability and improved type safety.

**Key concepts:**

**Type Parameter:** A placeholder for a type that is specified when a generic class, interface, or method is used. It is typically represented by a single uppercase letter within angle brackets, such as `<T>`.

**Type Argument:** The actual data type that replaces the type parameter. It is specified within angle brackets when creating an instance of a generic class or calling a generic method, such as `<String>`.

## Where Generics are Used
Generics are already prevalent in the Java Development Kit (JDK). A common example is the `ArrayList`.

### ArrayList Example
When creating an `ArrayList`, you specify the type of elements it will hold using a type argument:

```java
ArrayList<String> fruits = new ArrayList<>();
```
- `ArrayList`: The generic class.
- `<String>`: The type argument, specifying that this `ArrayList` will store `String` objects.
- `fruits`: The variable name for the `ArrayList`.
- `new ArrayList<>()`: The constructor call. In modern Java, the diamond operator `<>` can be used to infer the type argument, making the code more concise.

You can then add elements of the specified type:

```java
fruits.add("Apple");
fruits.add("Orange");
fruits.add("Banana");
```

If you attempt to add an element of a different type, a compile-time error will occur:

```java
// fruits.add(123); // This would cause a compile-time error
```

You can also change the type argument to store different data types:

```java
ArrayList<Integer> numbers = new ArrayList<>();
numbers.add(1);
numbers.add(2);
numbers.add(3);
```

The `ArrayList` class internally uses a type parameter (often represented by `E` for "Element") to make its methods and fields generic.

## Creating Generic Classes
You can create your own generic classes to encapsulate data and logic that can operate on various data types.

### Box Class Example
Consider a `Box` class designed to hold a single item. We can make it generic using a type parameter `<T>`.

```java
class Box<T> {
    private T item; // T is the type parameter

    public void setItem(T item) {
        this.item = item;
    }

    public T getItem() {
        return this.item;
    }
}
```
- `Box<T>`: Declares `Box` as a generic class with a type parameter `T`.
- `private T item;`: The `item` variable will hold an object of type `T`.
- `setItem(T item)`: A method to set the item, accepting an argument of type `T`.
- `getItem()`: A method to retrieve the item, returning an object of type `T`.

To use this generic `Box` class, you must provide a type argument:

```java
// Box for storing Strings
Box<String> stringBox = new Box<>();
stringBox.setItem("Hello");
String message = stringBox.getItem(); // message will be "Hello"

// Box for storing Integers
Box<Integer> integerBox = new Box<>();
integerBox.setItem(10);
Integer number = integerBox.getItem(); // number will be 10
```

Attempting to mix types will result in a compile-time error:

```java
// stringBox.setItem(123); // Compile-time error: incompatible types
```

### Generic Class with Multiple Type Parameters
A generic class can have more than one type parameter. Conventionally, if `T` is used, subsequent type parameters might be `U`, `V`, and so on.

#### Product Class Example
Consider a `Product` class that holds an item and its price. We can use two type parameters: `T` for the item and `U` for the price.

```java
class Product<T, U> {
    private T item;
    private U price;

    public Product(T item, U price) {
        this.item = item;
        this.price = price;
    }

    public T getItem() {
        return this.item;
    }

    public U getPrice() {
        return this.price;
    }
}
```
- `Product<T, U>`: Declares `Product` as a generic class with two type parameters, `T` and `U`.
- `Product(T item, U price)`: The constructor accepts arguments of type `T` and `U`.

To use this `Product` class, you provide two type arguments:

```java
// Product with String item and Double price
Product<String, Double> apple = new Product<>("Apple", 0.50);
String itemName = apple.getItem(); // "Apple"
Double itemPrice = apple.getPrice(); // 0.50

// Product with String item and Integer price
Product<String, Integer> movieTicket = new Product<>("Movie Ticket", 15);
String ticketName = movieTicket.getItem(); // "Movie Ticket"
Integer ticketPrice = movieTicket.getPrice(); // 15
```

## Benefits of Generics
**Type Safety:** Generics allow you to catch type errors at compile time rather than at runtime. This prevents `ClassCastException` errors.

**Code Reusability:** You can write a single generic class, interface, or method that can be used with different data types without having to rewrite the logic for each type.

**Readability:** Generic code is often more readable and easier to understand because it clearly expresses the intended types being used.

---

## Activities

### Activity 1: Generic Pair Class
Create a generic `Pair` class that can hold two objects of potentially different types. Include:
1. Constructor to initialize both objects
2. Getters for both objects
3. Setters for both objects
4. A method to swap the two objects
5. Test with different type combinations (String/Integer, Double/Boolean, etc.)

### Activity 2: Generic Stack Implementation
Create a generic `Stack<T>` class that implements basic stack operations:
1. `push(T item)` - adds an element to the top
2. `pop()` - removes and returns the top element
3. `peek()` - returns the top element without removing it
4. `isEmpty()` - checks if the stack is empty
5. `size()` - returns the number of elements
6. Test with Integer, String, and custom object types

### Activity 3: Generic Utility Methods
Create a class `ArrayUtils` with generic methods:
1. `reverse(T[] array)` - reverses an array of any type
2. `countOccurrences(T[] array, T element)` - counts how many times an element appears
3. `merge(T[] array1, T[] array2)` - merges two arrays of the same type
4. `findMax(T[] array, Comparator<T> comparator)` - finds the maximum element using a comparator
5. Test these methods with arrays of different types (Integer, String, custom objects)
