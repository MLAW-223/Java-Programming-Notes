# Java Abstraction

## What is Abstraction?
Abstraction is a fundamental concept in object-oriented programming that focuses on hiding implementation details and exposing only the essential features of an object or system.

Think of driving a car:
- **Essential Features:** You need to know how to use the gas pedal to accelerate and the brake pedal to stop.
- **Hidden Implementation Details:** You don't need to understand the complex workings of the engine, transmission, or braking system to drive the car.

In Java, abstraction is achieved using **abstract classes** and **abstract methods**.

## Abstract Classes

### Definition:
An abstract class is a class that is declared using the `abstract` keyword.

### Instantiability:
Abstract classes **cannot be instantiated directly**. You cannot create objects from an abstract class using the `new` keyword.

### Purpose:
They serve as blueprints for other classes, defining common properties and behaviors that subclasses are expected to have.

### Example:
In the provided material, `Shape` is an abstract class. You cannot create a `new Shape()` object because "Shape" is too generic. Instead, you create specific types of shapes like `Circle`, `Triangle`, or `Rectangle`.

```java
// Example of attempting to instantiate an abstract class (will cause an error)
// Shape genericShape = new Shape(); // ERROR: Shape is abstract; cannot be instantiated
```

### Contents:
Abstract classes can contain both:
- **Abstract Methods:** Methods declared with the `abstract` keyword, which have no implementation (body). Subclasses must provide an implementation for these methods.
- **Concrete Methods:** Regular methods with a defined implementation. These methods are inherited by subclasses and can be used directly or overridden.

## Abstract Methods

### Definition:
An abstract method is a method declared with the `abstract` keyword and no method body. It ends with a semicolon `;`.

### Requirement:
Any class that extends an abstract class must either:
1. Implement all of its abstract methods.
2. Be declared as abstract itself.

### Purpose:
They define a contract that subclasses must fulfill, ensuring that certain functionalities are available in all derived classes.

```java
// In the Shape abstract class:
abstract double area(); // This is an abstract method.
```

### Implementation in Subclasses:
When a concrete (non-abstract) class extends an abstract class, it must provide an implementation for all inherited abstract methods. This is typically done using the `@Override` annotation.

```java
// In the Circle class, which extends Shape:
@Override
double area() {
    // Implementation to calculate the area of a circle
    return Math.PI * radius * radius;
}
```

## Concrete Methods in Abstract Classes

### Definition:
Concrete methods within an abstract class are regular methods with a defined implementation.

### Inheritance:
These methods are inherited by subclasses and can be used directly without needing to be overridden.

### Purpose:
They provide common functionality that all subclasses can share.

```java
// In the Shape abstract class:
void display() { // This is a concrete method
    System.out.println("This is a shape");
}
```

### Usage in Subclasses:
A subclass can call this method directly.

```java
// In the Main class, creating a Circle object:
Circle circle = new Circle(3);
circle.display(); // Output: This is a shape
```

## Inheritance (extends Keyword)

### Relationship:
Abstract classes often serve as base classes (parent classes) for other classes. The `extends` keyword is used to establish this inheritance relationship.

### "Is-A" Relationship:
Inheritance signifies an "is-a" relationship. For example, a `Circle` is a `Shape`, a `Triangle` is a `Shape`, and a `Rectangle` is a `Shape`.

```java
public class Circle extends Shape {
    // ... implementation
}

public class Triangle extends Shape {
    // ... implementation
}

public class Rectangle extends Shape {
    // ... implementation
}
```

## Example: Shapes Hierarchy
The provided material demonstrates abstraction using a Shape hierarchy:

### Shape (Abstract Class):
- Cannot be instantiated.
- Has an abstract method `area()` that all specific shapes must implement.
- Has a concrete method `display()` that all shapes inherit.

### Circle, Triangle, Rectangle (Concrete Subclasses):
- Extend the `Shape` class.
- Must implement the `area()` method with their specific area calculation logic.
- Inherit the `display()` method from `Shape`.
- Can have their own constructors and attributes (e.g., `radius` for `Circle`, `base` and `height` for `Triangle`, `length` and `width` for `Rectangle`).

## Area Calculations
The material shows how subclasses implement the `area()` method to provide specific calculations:

### Circle:
- **Attributes:** `radius`
- **Formula:** Area = π × radius²
- **Java Implementation:** `return Math.PI * radius * radius;`

### Triangle:
- **Attributes:** `base`, `height`
- **Formula:** Area = ½ × base × height
- **Java Implementation:** `return 0.5 * base * height;`

### Rectangle:
- **Attributes:** `length`, `width`
- **Formula:** Area = length × width
- **Java Implementation:** `return length * width;`

## Example Usage (from Main class)

```java
// Creating objects of specific shapes
Circle circle = new Circle(3);
Triangle triangle = new Triangle(4, 5);
Rectangle rectangle = new Rectangle(6, 7);

// Calling the inherited concrete method
circle.display();    // Output: This is a shape
triangle.display();  // Output: This is a shape
rectangle.display(); // Output: This is a shape

// Calling the implemented abstract method to get areas
System.out.println(circle.area());    // Output: Approximately 28.274333882308138
System.out.println(triangle.area());  // Output: 10.0
System.out.println(rectangle.area()); // Output: 42.0
```

## Complete Code Example

### Abstract Class: Shape
```java
public abstract class Shape {
    // Abstract method - must be implemented by subclasses
    abstract double area();
    
    // Concrete method - can be used by all subclasses
    void display() {
        System.out.println("This is a shape");
    }
}
```

### Concrete Class: Circle
```java
public class Circle extends Shape {
    double radius;
    
    Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    double area() {
        return Math.PI * radius * radius;
    }
}
```

### Concrete Class: Triangle
```java
public class Triangle extends Shape {
    double base;
    double height;
    
    Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    @Override
    double area() {
        return 0.5 * base * height;
    }
}
```

### Concrete Class: Rectangle
```java
public class Rectangle extends Shape {
    double length;
    double width;
    
    Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }
    
    @Override
    double area() {
        return length * width;
    }
}
```

### Main Class
```java
public class Main {
    public static void main(String[] args) {
        // Creating objects of concrete classes
        Circle circle = new Circle(3);
        Triangle triangle = new Triangle(4, 5);
        Rectangle rectangle = new Rectangle(6, 7);
        
        // Using inherited concrete method
        circle.display();
        triangle.display();
        rectangle.display();
        
        // Using implemented abstract method
        System.out.println("Circle area: " + circle.area());
        System.out.println("Triangle area: " + triangle.area());
        System.out.println("Rectangle area: " + rectangle.area());
    }
}
```

## Key Benefits of Abstraction

### 1. Hiding Complexity
```java
abstract class DatabaseConnection {
    abstract void connect();
    abstract void disconnect();
    // Users don't need to know the complex implementation details
}

class MySQLConnection extends DatabaseConnection {
    @Override
    void connect() {
        // Complex MySQL connection logic
    }
    
    @Override
    void disconnect() {
        // Complex MySQL disconnection logic
    }
}
```

### 2. Ensuring Consistency
```java
abstract class PaymentProcessor {
    abstract boolean validate();
    abstract void process();
    // All payment processors must implement these methods
}

class CreditCardProcessor extends PaymentProcessor {
    @Override
    boolean validate() {
        // Credit card validation logic
        return true;
    }
    
    @Override
    void process() {
        // Credit card processing logic
    }
}
```

### 3. Promoting Code Reuse
```java
abstract class Vehicle {
    abstract void start();
    
    void checkFuel() {
        // Common fuel checking logic for all vehicles
        System.out.println("Checking fuel...");
    }
}
```

## Rules for Abstract Classes and Methods

### 1. Abstract Class Rules
```java
abstract class Animal {
    // Can have constructors
    Animal() {
        System.out.println("Animal constructor");
    }
    
    // Can have instance variables
    private String name;
    
    // Can have static methods
    static void staticMethod() {
        System.out.println("Static method");
    }
    
    // Can have final methods
    final void cannotOverride() {
        System.out.println("Cannot override this");
    }
}
```

### 2. Abstract Method Rules
```java
abstract class Example {
    // Abstract methods cannot be private
    // private abstract void method1(); // ERROR
    
    // Abstract methods cannot be static
    // static abstract void method2(); // ERROR
    
    // Abstract methods cannot be final
    // final abstract void method3(); // ERROR
    
    // Correct declaration
    abstract void method4();
}
```

### 3. Inheritance Rules
```java
abstract class Parent {
    abstract void method1();
    abstract void method2();
}

// Option 1: Implement all abstract methods
class Child1 extends Parent {
    @Override
    void method1() { /* ... */ }
    
    @Override
    void method2() { /* ... */ }
}

// Option 2: Declare as abstract (defer implementation)
abstract class Child2 extends Parent {
    @Override
    void method1() { /* ... */ }
    // method2() is still abstract
}

// Option 3: ERROR - must implement or declare abstract
// class Child3 extends Parent { } // COMPILATION ERROR
```

## Practical Examples

### Example 1: Employee Management System
```java
abstract class Employee {
    private String name;
    private int id;
    
    Employee(String name, int id) {
        this.name = name;
        this.id = id;
    }
    
    // Abstract method - must be implemented by subclasses
    abstract double calculateSalary();
    
    // Concrete method - can be used by all subclasses
    String getDetails() {
        return "Name: " + name + ", ID: " + id;
    }
}

class FullTimeEmployee extends Employee {
    private double monthlySalary;
    
    FullTimeEmployee(String name, int id, double monthlySalary) {
        super(name, id);
        this.monthlySalary = monthlySalary;
    }
    
    @Override
    double calculateSalary() {
        return monthlySalary;
    }
}

class PartTimeEmployee extends Employee {
    private double hourlyRate;
    private int hoursWorked;
    
    PartTimeEmployee(String name, int id, double hourlyRate, int hoursWorked) {
        super(name, id);
        this.hourlyRate = hourlyRate;
        this.hoursWorked = hoursWorked;
    }
    
    @Override
    double calculateSalary() {
        return hourlyRate * hoursWorked;
    }
}
```

### Example 2: Notification System
```java
abstract class Notification {
    private String recipient;
    private String message;
    
    Notification(String recipient, String message) {
        this.recipient = recipient;
        this.message = message;
    }
    
    // Abstract method - each notification type sends differently
    abstract void send();
    
    // Concrete method - common formatting
    String formatMessage() {
        return "To: " + recipient + "\nMessage: " + message;
    }
    
    // Concrete method - common validation
    boolean validate() {
        return recipient != null && !recipient.isEmpty() &&
               message != null && !message.isEmpty();
    }
}

class EmailNotification extends Notification {
    private String subject;
    
    EmailNotification(String recipient, String subject, String message) {
        super(recipient, message);
        this.subject = subject;
    }
    
    @Override
    void send() {
        if (validate()) {
            System.out.println("Sending email...");
            System.out.println("Subject: " + subject);
            System.out.println(formatMessage());
        }
    }
}

class SMSNotification extends Notification {
    SMSNotification(String recipient, String message) {
        super(recipient, message);
    }
    
    @Override
    void send() {
        if (validate() && getMessage().length() <= 160) {
            System.out.println("Sending SMS...");
            System.out.println("To: " + getRecipient());
            System.out.println("Message: " + getMessage());
        }
    }
    
    // Helper methods to access private fields from parent
    private String getRecipient() {
        // In real code, we'd use getter methods
        return "recipient";
    }
    
    private String getMessage() {
        return "message";
    }
}
```

### Example 3: Game Character System
```java
abstract class GameCharacter {
    protected String name;
    protected int health;
    protected int level;
    
    GameCharacter(String name, int health, int level) {
        this.name = name;
        this.health = health;
        this.level = level;
    }
    
    // Abstract methods - each character type fights differently
    abstract void attack();
    abstract void defend();
    
    // Concrete methods - common to all characters
    boolean isAlive() {
        return health > 0;
    }
    
    void takeDamage(int damage) {
        health -= damage;
        if (health < 0) health = 0;
    }
    
    void displayStatus() {
        System.out.println(name + " - Health: " + health + 
                          ", Level: " + level);
    }
}

class Warrior extends GameCharacter {
    private int strength;
    
    Warrior(String name, int health, int level, int strength) {
        super(name, health, level);
        this.strength = strength;
    }
    
    @Override
    void attack() {
        System.out.println(name + " attacks with sword!");
        System.out.println("Damage: " + (strength * level));
    }
    
    @Override
    void defend() {
        System.out.println(name + " raises shield!");
        System.out.println("Defense increased!");
    }
}

class Mage extends GameCharacter {
    private int magicPower;
    
    Mage(String name, int health, int level, int magicPower) {
        super(name, health, level);
        this.magicPower = magicPower;
    }
    
    @Override
    void attack() {
        System.out.println(name + " casts fireball!");
        System.out.println("Damage: " + (magicPower * level));
    }
    
    @Override
    void defend() {
        System.out.println(name + " creates magic barrier!");
        System.out.println("Magic defense increased!");
    }
}
```

## Common Patterns

### Template Method Pattern
```java
abstract class DataProcessor {
    // Template method - defines algorithm skeleton
    final void process() {
        readData();
        processData();
        writeData();
    }
    
    abstract void readData();
    abstract void processData();
    
    void writeData() {
        System.out.println("Writing data...");
    }
}

class CSVProcessor extends DataProcessor {
    @Override
    void readData() {
        System.out.println("Reading CSV data...");
    }
    
    @Override
    void processData() {
        System.out.println("Processing CSV data...");
    }
}
```

### Factory Method Pattern
```java
abstract class Document {
    abstract void open();
    abstract void save();
}

abstract class Application {
    abstract Document createDocument();
    
    void newDocument() {
        Document doc = createDocument();
        doc.open();
    }
}

class WordDocument extends Document {
    @Override
    void open() {
        System.out.println("Opening Word document");
    }
    
    @Override
    void save() {
        System.out.println("Saving Word document");
    }
}

class WordApplication extends Application {
    @Override
    Document createDocument() {
        return new WordDocument();
    }
}
```

## Best Practices

### 1. Use Abstract Classes for "Is-A" Relationships
```java
// Good: Circle IS-A Shape
abstract class Shape { }
class Circle extends Shape { }

// Bad: Car IS-NOT an Engine
// abstract class Engine { }
// class Car extends Engine { } // Wrong relationship
```

### 2. Keep Abstract Classes Focused
```java
// Good: Single responsibility
abstract class PaymentProcessor {
    abstract boolean processPayment(double amount);
}

// Bad: Too many responsibilities
// abstract class BusinessLogic {
//     abstract void processPayment();
//     abstract void sendEmail();
//     abstract void generateReport();
// }
```

### 3. Provide Default Implementations When Possible
```java
abstract class Logger {
    // Provide default implementation for common cases
    void log(String message) {
        log(message, "INFO");
    }
    
    abstract void log(String message, String level);
}
```

### 4. Use Final for Template Methods
```java
abstract class Algorithm {
    // Template method should be final to prevent overriding
    final void execute() {
        initialize();
        compute();
        cleanup();
    }
    
    abstract void initialize();
    abstract void compute();
    abstract void cleanup();
}
```

## Common Mistakes

### Mistake 1: Instantiating Abstract Classes
```java
abstract class Animal { }
// Animal animal = new Animal(); // ERROR: Cannot instantiate
```

### Mistake 2: Forgetting to Implement Abstract Methods
```java
abstract class Parent {
    abstract void method();
}

class Child extends Parent {
    // ERROR: Must implement method() or declare abstract
}
```

### Mistake 3: Mixing Abstract and Interface Concepts
```java
// Don't use abstract classes like interfaces
// abstract class Runnable { // Use interface instead
//     abstract void run();
// }
```

---

## Activities

### Activity 1: Bank Account System with Abstraction
Create an abstract banking system:
1. **Abstract class:** `BankAccount` with:
   - Abstract methods: `deposit()`, `withdraw()`, `calculateInterest()`
   - Concrete methods: `getBalance()`, `displayAccountInfo()`
   - Attributes: accountNumber, accountHolder, balance
2. **Concrete classes:**
   - `SavingsAccount`: interestRate, minimumBalance
   - `CheckingAccount`: overdraftLimit, monthlyFee
   - `CreditAccount`: creditLimit, annualFee
3. **Requirements:**
   - Each account type must implement abstract methods differently
   - Create methods that work with BankAccount array (polymorphism)
   - Demonstrate that BankAccount cannot be instantiated
   - Test all account types with various transactions

### Activity 2: Media Player System
Create an abstract media player:
1. **Abstract class:** `MediaPlayer` with:
   - Abstract methods: `play()`, `pause()`, `stop()`, `getDuration()`
   - Concrete methods: `displayInfo()`, `isPlaying()`
   - Attributes: title, artist, fileSize
2. **Concrete classes:**
   - `AudioPlayer`: volume, bitrate, format
   - `VideoPlayer`: resolution, subtitles, aspectRatio
3. **Requirements:**
   - Implement media-specific playback logic
   - Add format validation in each concrete class
   - Create a playlist that can hold different media types
   - Demonstrate abstraction by calling play() on different media types

### Activity 3: Online Store with Abstract Products
Create an abstract product system:
1. **Abstract class:** `Product` with:
   - Abstract methods: `calculateDiscount()`, `applyTax()`, `getFinalPrice()`
   - Concrete methods: `displayProduct()`, `checkAvailability()`
   - Attributes: productId, name, basePrice, stock
2. **Concrete classes:**
   - `ElectronicsProduct`: warranty, brand, powerConsumption
   - `ClothingProduct`: size, color, material, season
   - `FoodProduct`: expiryDate, weight, nutritionalInfo
3. **Requirements:**
   - Each product type calculates discounts and taxes differently
   - Implement product-specific validation
   - Create shopping cart that accepts any Product type
   - Calculate total cart value using abstraction
   - Demonstrate that Product cannot be instantiated directly
