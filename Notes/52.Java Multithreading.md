# Java Multithreading

## Introduction to Multithreading
Multithreading allows a program to execute multiple threads concurrently, meaning at the same time. A thread is essentially a sequence of instructions that can run independently of other threads.

**Why Use Multithreading?**
- **Background Tasks:** Perform operations without blocking the main program flow.
- **Time-Consuming Operations:** Handle lengthy processes (e.g., network requests, file I/O) without freezing the user interface.

## Creating Threads in Java
There are two primary ways to create threads in Java:

**Extending the `Thread` Class:** You can create a class that extends `java.lang.Thread` and override its `run()` method.

**Implementing the `Runnable` Interface:** This is generally the preferred approach. You create a class that implements the `java.lang.Runnable` interface and provides an implementation for the `run()` method. This is favored because Java does not support multiple inheritance, so extending `Thread` would prevent your class from extending other classes.

## Implementing the Runnable Interface
When you implement the `Runnable` interface, you are essentially agreeing to provide a definition for the `run()` method. The code within this `run()` method is what will be executed when the thread is started.

**Example Structure:**
```java
public class MyRunnable implements Runnable {
    private String message; // Optional: for differentiating threads

    // Constructor to pass in data (like a message)
    public MyRunnable(String message) {
        this.message = message;
    }

    @Override
    public void run() {
        // Code to be executed by the thread
        for (int i = 0; i < 5; i++) {
            try {
                // Pause the thread for 1 second (1000 milliseconds)
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("Thread was interrupted");
            }
            // Print the message associated with this thread
            System.out.println(message);
        }
    }
}
```

## Running Threads
To run a thread, you first create an instance of your `Runnable` implementation, then create a `Thread` object, passing your `Runnable` instance to the `Thread` constructor. Finally, you call the `start()` method on the `Thread` object.

**Starting a Single Thread**
```java
// In your main method or another class:
MyRunnable myRunnable = new MyRunnable("Task 1");
Thread thread1 = new Thread(myRunnable);
thread1.start(); // This executes the run() method of myRunnable
```

**Using Anonymous Runnable Objects**
A more concise way to create and start threads is by using an anonymous `Runnable` object directly within the `Thread` constructor:

```java
// In your main method or another class:
Thread thread1 = new Thread(new MyRunnable("Task 1"));
thread1.start();

// Or even more concise with an anonymous inner class:
Thread thread2 = new Thread(new Runnable() {
    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("Thread was interrupted");
            }
            System.out.println("Anonymous Task");
        }
    }
});
thread2.start();
```

## Running Multiple Threads
You can create and start multiple `Thread` objects to run concurrently.

```java
// In your main method or another class:
Thread thread1 = new Thread(new MyRunnable("PING"));
Thread thread2 = new Thread(new MyRunnable("PONG"));

System.out.println("GAME START!");

thread1.start();
thread2.start();
```

When multiple threads run concurrently, their execution order is not guaranteed. They may interleave their output.

## Thread Synchronization and Waiting

### The join() Method
By default, the main thread (the thread that executes your `main` method) does not wait for other threads to complete. If you want the main thread to wait until one or more other threads have finished their execution, you can use the `join()` method.

The `join()` method causes the current thread (e.g., the main thread) to pause execution and wait until the thread on which `join()` was called terminates.

**Important:** The `join()` method can throw an `InterruptedException`, so it must be wrapped in a try-catch block.

**Example with join()**
```java
public class Main {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new MyRunnable("PING"));
        Thread thread2 = new Thread(new MyRunnable("PONG"));

        System.out.println("GAME START!");

        thread1.start();
        thread2.start();

        try {
            // Main thread waits for thread1 to finish
            thread1.join();
            // Main thread waits for thread2 to finish
            thread2.join();
        } catch (InterruptedException e) {
            System.out.println("Main thread was interrupted");
        }

        System.out.println("GAME OVER!");
    }
}
```

In this example, "GAME OVER!" will only be printed after both `thread1` and `thread2` have completed their `run()` methods.

### The sleep() Method
The `Thread.sleep(long milliseconds)` method causes the currently executing thread to pause for the specified number of milliseconds. This is useful for introducing delays or allowing other threads a chance to run. It also throws an `InterruptedException`.

## Thread Naming
Threads can be given names, which can be helpful for debugging and understanding the output of concurrent programs.

**Getting the Current Thread's Name:** `Thread.currentThread().getName()`

**Setting a Thread's Name:** You can provide a name in the `Thread` constructor: `new Thread(myRunnable, "MyThreadName");`

**Example of Using Names in Output:**
```java
public class MyRunnable implements Runnable {
    private String message;

    public MyRunnable(String message) {
        this.message = message;
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println("Thread was interrupted");
            }
            // Get the name of the thread executing this run() method
            String threadName = Thread.currentThread().getName();
            System.out.println(threadName + ": " + message);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Thread thread1 = new Thread(new MyRunnable("PING"), "Thread-1");
        Thread thread2 = new Thread(new MyRunnable("PONG"), "Thread-2");

        System.out.println("GAME START!");

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            System.out.println("Main thread was interrupted");
        }

        System.out.println("GAME OVER!");
    }
}
```

---

## Activities

### Activity 1: Number Printer with Thread Coordination
Create a program with two threads:
- Thread A prints even numbers from 0 to 10
- Thread B prints odd numbers from 1 to 9
- Use `join()` to ensure the output is sequential (all evens then all odds or vice versa)
- Then modify to interleave the output (0, 1, 2, 3, ...) using thread coordination

### Activity 2: Parallel Array Processing
Create an array of 100 random integers. Use 4 threads to:
- Thread 1: Find and print the maximum value in its assigned quarter of the array
- Thread 2: Find and print the minimum value
- Thread 3: Calculate and print the sum
- Thread 4: Calculate and print the average
- Use `join()` to wait for all threads before displaying final results

### Activity 3: Restaurant Simulation
Simulate a restaurant kitchen with multiple chefs (threads):
- Create 3 chef threads that prepare different types of dishes
- Each dish preparation takes a random time (1-5 seconds)
- Create a waiter thread that collects completed dishes
- The restaurant should close after 20 dishes are prepared
- Use proper thread synchronization and naming for debugging
