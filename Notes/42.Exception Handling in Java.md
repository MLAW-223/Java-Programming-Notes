# Exception Handling in Java

Exception handling is a crucial concept in Java programming that allows developers to manage errors and unexpected events that can disrupt the normal execution of a program. This study guide provides a comprehensive overview of exceptions in Java, including types, handling mechanisms, and practical examples.

## What is an Exception?
An exception is an event that interrupts the normal flow of a program. Common causes of exceptions include:

- Dividing by zero.
- File not found errors.
- Mismatched input types (e.g., expecting a number but receiving a string).

Exceptions can occur during runtime and need to be handled to prevent the program from crashing.

## Exception Handling Mechanism
Java provides a structured way to handle exceptions using the following blocks:

**try:** This block is used to wrap code that may throw an exception. If an exception occurs, control is transferred to the catch block.

**catch:** This block is used to define what happens if an exception of a particular type occurs. Multiple catch blocks can be used for different exception types.

**finally:** This optional block always executes after the try and catch blocks, regardless of whether an exception was thrown. It is typically used for cleanup operations (e.g., closing files or freeing resources).

## Basic Syntax
```java
try {
    // Code that may throw an exception
} catch (ExceptionType1 e) {
    // Handling for exception type 1
} catch (ExceptionType2 e) {
    // Handling for exception type 2
} finally {
    // Code that always executes
}
```

## Types of Exceptions
In Java, exceptions can be categorized mainly into two types:

**Checked Exceptions:** These are exceptions that must be either caught or declared in the method signature. Examples include `IOException` and `SQLException`.

**Unchecked Exceptions:** Also known as runtime exceptions, these are exceptions that do not require explicit handling. Examples include `ArithmeticException`, `NullPointerException`, and `InputMismatchException`.

## Example of Exception Handling
Here's a practical example demonstrating how to handle exceptions in Java using user input:

```java
import java.util.InputMismatchException;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(System.in)) {
            System.out.print("Enter a number: ");
            int number = scanner.nextInt();
            System.out.println("You entered: " + number);
        } catch (InputMismatchException e) {
            System.out.println("That wasn't a number!");
        } catch (ArithmeticException e) {
            System.out.println("YOU CAN'T DIVIDE BY ZERO!");
        } catch (Exception e) {
            System.out.println("Something went wrong");
        } finally {
            System.out.println("This always executes");
        }
    }
}
```

## Explanation of the Example
**User Input:** The program prompts the user to enter a number.

**try Block:** The code that reads the input is placed inside a try block. If the user inputs a non-integer (like a string), an `InputMismatchException` is thrown.

**catch Blocks:**
- The first catch handles `InputMismatchException` and informs the user that the input was invalid.
- The second catch could handle `ArithmeticException` if there was code for division by zero, which is not present in this specific example.
- The final catch acts as a safety net for any other exceptions that might occur.

**finally Block:** This block prints a message that always executes, ensuring that important cleanup code can be placed here (e.g., closing resources).

## Using Try-With-Resources
Java also offers a more convenient way to manage resources using the "try-with-resources" statement. This automatically closes resources such as file streams or scanners when done:

```java
try (Scanner scanner = new Scanner(System.in)) {
    // Code that uses the scanner
} catch (InputMismatchException e) {
    // Handle input mismatch
}
// No need for finally block to close scanner
```

## Best Practices
- Always catch specific exceptions before catching general exceptions. This helps provide accurate feedback to users about what went wrong.
- Use the `finally` block for cleanup code, ensuring necessary resources are released regardless of whether an exception occurred.
- Avoid using the catch-all exception handler (`catch (Exception e)`) unless necessary, as it may obscure specific issues.

Through proper exception handling, Java developers can create robust applications that gracefully manage errors and provide users with informative messages about any issues that arise.

---

## Activities

### Activity 1: Division Calculator with Exception Handling
Create a program that asks the user for two numbers and divides them. Handle the following exceptions:
- `ArithmeticException` for division by zero
- `InputMismatchException` for invalid number input
- `Exception` as a general catch-all
Include a `finally` block that displays "Calculation complete" regardless of the outcome.

### Activity 2: File Reader with Exception Handling
Create a program that reads a filename from the user and attempts to open and read the file. Handle:
- `FileNotFoundException` if the file doesn't exist
- `IOException` for general file reading errors
- `SecurityException` if file access is denied
Use try-with-resources to automatically close the file reader.

### Activity 3: Array Index and Null Pointer Exception Handler
Create a program that:
1. Creates an array of 5 integers
2. Asks the user for an index to access
3. Handles `ArrayIndexOutOfBoundsException` if the index is invalid
4. Modifies the program to include a null reference and handle `NullPointerException`
5. Show how multiple specific exceptions can be caught before a general exception
