# Method Overriding in Java

## What is Method Overriding?
Method overriding occurs when a subclass provides its own specific implementation of a method that is already defined in its parent class. This allows for code reusability while also enabling the creation of specialized behavior for different subclasses.

## Key Concepts
- **Inheritance:** Method overriding relies on inheritance, where a subclass (child class) inherits methods from a superclass (parent class).
- **Subclass Implementation:** The subclass defines a method with the same name, return type, and parameter list as a method in its superclass.
- **Specific Behavior:** The overridden method in the subclass provides a unique implementation that is more appropriate for the subclass's specific nature.
- **@Override Annotation:** This is a crucial annotation used in Java.
  - It indicates that a method is intended to override a method from a superclass.
  - It helps the compiler detect errors, such as typos in the method name or incorrect parameter lists, which would prevent the method from actually overriding the superclass method.
  - It improves code readability by clearly signaling the intent to override.

## How Method Overriding Works
When a method is called on an object, the Java Virtual Machine (JVM) checks if the object's class has implemented that method. If it has, that implementation is used. If not, the JVM checks the parent class, and so on, up the inheritance hierarchy.

If a subclass overrides a method from its parent class, the subclass's implementation takes precedence. This means that when the method is called on an object of the subclass, the overridden method in the subclass will be executed, not the method in the parent class.

## Example
Let's consider an Animal class with a `move()` method and subclasses Dog, Cat, and Fish.

```java
// Parent class
public class Animal {
    void move() {
        System.out.println("This animal is running");
    }
}

// Subclass Dog
public class Dog extends Animal {
    // Inherits the move() method from Animal
    // No specific implementation needed here if the parent's behavior is sufficient
}

// Subclass Cat
public class Cat extends Animal {
    // Inherits the move() method from Animal
    // No specific implementation needed here if the parent's behavior is sufficient
}

// Subclass Fish
public class Fish extends Animal {
    @Override // Annotation indicating this method overrides a superclass method
    void move() {
        System.out.println("This animal is swimming");
    }
}

// Main class to demonstrate
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Cat cat = new Cat();
        Fish fish = new Fish();

        dog.move(); // Output: This animal is running
        cat.move(); // Output: This animal is running
        fish.move(); // Output: This animal is swimming
    }
}
```

In this example:
- The `Animal` class has a `move()` method that prints "This animal is running".
- The `Dog` and `Cat` classes inherit this `move()` method directly from `Animal` and use its implementation.
- The `Fish` class overrides the `move()` method. It provides its own implementation that prints "This animal is swimming", which is more appropriate for a fish.
- The `@Override` annotation is used in the `Fish` class to clearly mark the `move()` method as an overridden method and to help the compiler catch potential errors.

## Benefits of Method Overriding
- **Polymorphism:** Method overriding is a key component of polymorphism, allowing objects of different classes to be treated as objects of a common superclass, but still exhibit their specific behaviors.
- **Code Reusability:** It allows subclasses to reuse the general functionality provided by the parent class while customizing specific parts.
- **Extensibility:** New subclasses can be added with their own specialized versions of methods without altering the original parent class.
- **Maintainability:** It makes code easier to understand and maintain by clearly defining specific behaviors for different object types.

## @Override Annotation: Importance and Error Detection
The `@Override` annotation is more than just a marker; it's a compile-time safety net. Consider what might happen if you intended to override `move()` in the Fish class but accidentally misspelled it as `moves()`:

```java
public class Fish extends Animal {
    @Override // This annotation will now cause a compile-time error
    void moves() { // Typo: 's' added at the end
        System.out.println("This animal is swimming");
    }
}
```

Without the `@Override` annotation, the compiler would simply create a new, unrelated method named `moves()` in the Fish class. The `move()` method inherited from Animal would still be available, and calling `fish.move()` would result in "This animal is running" (or whatever the parent's implementation is), which is likely not the intended behavior.

However, with `@Override`, the compiler recognizes that `moves()` does not match any method signature in the Animal superclass. It will immediately flag this as an error: "method does not override method from its superclass." This prevents subtle bugs where a developer believes a method is being overridden when it actually isn't.

## Rules for Method Overriding

### 1. Method Signature Must Match
```java
class Parent {
    void display(int x) { /* ... */ }
}

class Child extends Parent {
    @Override
    void display(int x) { /* ... */ } // OK: Same signature
    
    // void display(String x) { } // NOT overriding - different parameter type
    // int display(int x) { }     // NOT overriding - different return type
}
```

### 2. Access Modifier Cannot Be More Restrictive
```java
class Parent {
    public void show() { /* ... */ }
}

class Child extends Parent {
    @Override
    public void show() { /* ... */ }     // OK: Same or less restrictive
    // protected void show() { }         // ERROR: More restrictive
    // private void show() { }           // ERROR: More restrictive
}
```

### 3. Cannot Override Final Methods
```java
class Parent {
    final void cannotOverride() { /* ... */ }
}

class Child extends Parent {
    // @Override
    // void cannotOverride() { } // ERROR: Cannot override final method
}
```

### 4. Cannot Override Static Methods
```java
class Parent {
    static void staticMethod() { /* ... */ }
}

class Child extends Parent {
    // This is method hiding, not overriding
    static void staticMethod() { /* ... */ }
}
```

### 5. Can Override with Covariant Return Types
```java
class Parent {
    Parent getInstance() { return new Parent(); }
}

class Child extends Parent {
    @Override
    Child getInstance() { return new Child(); } // Covariant return type
}
```

## Using `super` in Overridden Methods
```java
class Parent {
    void display() {
        System.out.println("Parent display");
    }
}

class Child extends Parent {
    @Override
    void display() {
        super.display(); // Call parent's implementation
        System.out.println("Child display");
    }
}

// Usage
Child child = new Child();
child.display();
// Output:
// Parent display
// Child display
```

## Polymorphism with Method Overriding
```java
class Animal {
    void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Cat meows");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal;
        
        myAnimal = new Dog();
        myAnimal.makeSound(); // Output: Dog barks
        
        myAnimal = new Cat();
        myAnimal.makeSound(); // Output: Cat meows
        
        // Using array for polymorphism
        Animal[] animals = {new Dog(), new Cat(), new Animal()};
        for (Animal animal : animals) {
            animal.makeSound();
        }
        // Output:
        // Dog barks
        // Cat meows
        // Animal makes a sound
    }
}
```

## Practical Examples

### Example 1: Shape Hierarchy
```java
abstract class Shape {
    abstract double calculateArea();
    abstract double calculatePerimeter();
    
    void display() {
        System.out.println("Area: " + calculateArea());
        System.out.println("Perimeter: " + calculatePerimeter());
    }
}

class Circle extends Shape {
    double radius;
    
    Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    double calculateArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
    
    @Override
    void display() {
        System.out.println("Circle with radius " + radius);
        super.display(); // Call parent's display method
    }
}

class Rectangle extends Shape {
    double length;
    double width;
    
    Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }
    
    @Override
    double calculateArea() {
        return length * width;
    }
    
    @Override
    double calculatePerimeter() {
        return 2 * (length + width);
    }
    
    @Override
    void display() {
        System.out.println("Rectangle " + length + "x" + width);
        super.display();
    }
}
```

### Example 2: Bank Account System
```java
class BankAccount {
    protected double balance;
    protected String accountNumber;
    
    BankAccount(String accountNumber, double balance) {
        this.accountNumber = accountNumber;
        this.balance = balance;
    }
    
    void deposit(double amount) {
        balance += amount;
        System.out.println("Deposited: $" + amount);
    }
    
    void withdraw(double amount) {
        if (amount <= balance) {
            balance -= amount;
            System.out.println("Withdrew: $" + amount);
        } else {
            System.out.println("Insufficient funds");
        }
    }
    
    void displayBalance() {
        System.out.println("Account " + accountNumber + 
                          " balance: $" + balance);
    }
}

class SavingsAccount extends BankAccount {
    private double interestRate;
    
    SavingsAccount(String accountNumber, double balance, double interestRate) {
        super(accountNumber, balance);
        this.interestRate = interestRate;
    }
    
    @Override
    void withdraw(double amount) {
        if (balance - amount >= 100) { // Minimum balance requirement
            super.withdraw(amount);
        } else {
            System.out.println("Cannot withdraw below minimum balance of $100");
        }
    }
    
    void addInterest() {
        double interest = balance * interestRate / 100;
        deposit(interest);
        System.out.println("Interest added: $" + interest);
    }
    
    @Override
    void displayBalance() {
        super.displayBalance();
        System.out.println("Interest rate: " + interestRate + "%");
    }
}

class CheckingAccount extends BankAccount {
    private double overdraftLimit;
    
    CheckingAccount(String accountNumber, double balance, double overdraftLimit) {
        super(accountNumber, balance);
        this.overdraftLimit = overdraftLimit;
    }
    
    @Override
    void withdraw(double amount) {
        if (balance + overdraftLimit >= amount) {
            balance -= amount;
            System.out.println("Withdrew: $" + amount);
            if (balance < 0) {
                System.out.println("Overdraft used. Balance: $" + balance);
            }
        } else {
            System.out.println("Exceeds overdraft limit");
        }
    }
    
    @Override
    void displayBalance() {
        super.displayBalance();
        System.out.println("Overdraft limit: $" + overdraftLimit);
    }
}
```

### Example 3: Employee Management System
```java
class Employee {
    protected String name;
    protected int id;
    protected double baseSalary;
    
    Employee(String name, int id, double baseSalary) {
        this.name = name;
        this.id = id;
        this.baseSalary = baseSalary;
    }
    
    double calculateSalary() {
        return baseSalary;
    }
    
    void displayInfo() {
        System.out.println("Name: " + name);
        System.out.println("ID: " + id);
        System.out.println("Salary: $" + calculateSalary());
    }
}

class Manager extends Employee {
    private double bonus;
    
    Manager(String name, int id, double baseSalary, double bonus) {
        super(name, id, baseSalary);
        this.bonus = bonus;
    }
    
    @Override
    double calculateSalary() {
        return baseSalary + bonus;
    }
    
    @Override
    void displayInfo() {
        super.displayInfo();
        System.out.println("Position: Manager");
        System.out.println("Bonus: $" + bonus);
    }
}

class Developer extends Employee {
    private int overtimeHours;
    private double hourlyRate;
    
    Developer(String name, int id, double baseSalary, 
              double hourlyRate) {
        super(name, id, baseSalary);
        this.hourlyRate = hourlyRate;
        this.overtimeHours = 0;
    }
    
    void addOvertime(int hours) {
        overtimeHours += hours;
    }
    
    @Override
    double calculateSalary() {
        return baseSalary + (overtimeHours * hourlyRate);
    }
    
    @Override
    void displayInfo() {
        super.displayInfo();
        System.out.println("Position: Developer");
        System.out.println("Overtime hours: " + overtimeHours);
        System.out.println("Hourly rate: $" + hourlyRate);
    }
}
```

## Common Mistakes and Best Practices

### Common Mistake 1: Forgetting @Override Annotation
```java
class Parent {
    void show() { /* ... */ }
}

class Child extends Parent {
    void show() { /* ... */ } // Works but no compile-time safety
    // Better: @Override void show() { ... }
}
```

### Common Mistake 2: Changing Method Signature
```java
class Parent {
    void process(int x) { /* ... */ }
}

class Child extends Parent {
    @Override
    void process(String x) { /* ... */ } // ERROR: Different parameter type
}
```

### Best Practice 1: Always Use @Override
```java
class Child extends Parent {
    @Override // Always use this annotation
    void method() { /* ... */ }
}
```

### Best Practice 2: Document Overridden Methods
```java
class Child extends Parent {
    /**
     * {@inheritDoc}
     * Also performs additional validation specific to Child class.
     */
    @Override
    void process() {
        // Additional logic
        super.process();
    }
}
```

### Best Practice 3: Use Final for Methods That Shouldn't Be Overridden
```java
class Parent {
    final void criticalOperation() {
        // This method should never be changed by subclasses
    }
}
```

## Method Overriding vs Method Overloading

| Feature | Method Overriding | Method Overloading |
|---------|-------------------|-------------------|
| **Purpose** | Provide specific implementation | Perform similar operations with different inputs |
| **Inheritance** | Requires inheritance | Can be in same class |
| **Method Signature** | Must match exactly | Must differ |
| **Return Type** | Must be same or covariant | Can be different |
| **Access Modifier** | Cannot be more restrictive | Can be different |
| **Polymorphism** | Runtime polymorphism | Compile-time polymorphism |
| **@Override** | Required/Recommended | Not applicable |

---

## Activities

### Activity 1: Vehicle Hierarchy with Method Overriding
Create a vehicle hierarchy:
1. **Base class:** `Vehicle` with methods `start()`, `stop()`, `displayInfo()`
2. **Derived classes:** `Car`, `Motorcycle`, `Truck`, `Bicycle`
3. **Requirements:**
   - Override `start()` and `stop()` methods with vehicle-specific messages
   - Override `displayInfo()` to show vehicle-specific details
   - Use `@Override` annotation for all overridden methods
   - Demonstrate polymorphism by storing different vehicles in an array
4. Create a test program that creates one of each vehicle type and calls their methods

### Activity 2: Notification System with Method Overriding
Create a notification system:
1. **Base class:** `Notification` with methods `send()`, `getPriority()`, `formatMessage()`
2. **Derived classes:**
   - `EmailNotification`: recipientEmail, subject
   - `SMSNotification`: phoneNumber
   - `PushNotification`: deviceToken, appName
3. **Requirements:**
   - Override `send()` method for each notification type
   - Override `formatMessage()` to format messages appropriately
   - Add validation methods that are overridden in subclasses
   - Create a method that accepts `Notification[]` and sends all notifications
4. Test with different notification types and invalid data

### Activity 3: Payment Processing System
Create a payment processing system:
1. **Base class:** `Payment` with methods `processPayment()`, `validate()`, `generateReceipt()`
2. **Derived classes:**
   - `CreditCardPayment`: cardNumber, expiryDate, cvv
   - `PayPalPayment`: email, transactionId
   - `BankTransferPayment`: accountNumber, routingNumber
3. **Requirements:**
   - Override `processPayment()` with payment-specific logic
   - Override `validate()` to validate payment method details
   - Override `generateReceipt()` to create appropriate receipts
   - Implement different security checks for each payment method
   - Use `super` to call parent methods where appropriate
4. Create a shopping cart that can accept different payment types
