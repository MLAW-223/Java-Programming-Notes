# Java Threading

## Introduction to Threading
Threading in Java allows a program to execute multiple tasks concurrently. This is beneficial for improving performance, especially with time-consuming operations such as file input/output, network communications, or any background tasks. By offloading these operations to separate threads, the main program can remain responsive.

## Creating Threads
There are two primary ways to create threads in Java:

**Extend the `Thread` class:** This is a simpler approach but is limited by Java's single inheritance rule. A class can only extend one other class.

**Implement the `Runnable` interface:** This is generally considered the better approach. It allows a class to implement multiple interfaces, providing more flexibility.

The video demonstration focuses on implementing the `Runnable` interface.

## Implementing the Runnable Interface
To implement the `Runnable` interface:

1. Create a new Java class.
2. Make this class implement the `Runnable` interface.
3. This requires overriding the `run()` method. The `@Override` annotation should be used.
4. Any code that you want to execute on a separate thread should be placed within the `run()` method.

**Example (MyRunnable.java):**
```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // Code to run on a separate thread
        for (int i = 1; i <= 5; i++) {
            System.out.println("Countdown: " + i);
            try {
                Thread.sleep(1000); // Pause for 1000 milliseconds (1 second)
            } catch (InterruptedException e) {
                System.out.println("Thread was interrupted");
            }
        }
        System.out.println("Times up!");
    }
}
```

## Starting a Thread
To start a thread that implements `Runnable`:

1. Create an instance of your `Runnable` class.
2. Create a new `Thread` object, passing your `Runnable` instance to its constructor.
3. Call the `start()` method on the `Thread` object. This method executes the `run()` method of your `Runnable` object in a new thread.

**Example (Main.java):**
```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start(); // Start the new thread

        System.out.println("You have 5 seconds to enter your name");
        System.out.print("Enter your name: ");
        String name = scanner.nextLine();
        System.out.println("Hello " + name);

        scanner.close();
    }
}
```

## Thread Behavior and Control

### Thread.sleep()
The `Thread.sleep(long milliseconds)` method causes the currently executing thread to pause for the specified number of milliseconds. This method can throw an `InterruptedException`, so it must be used within a try-catch block.

### Daemon Threads
Daemon threads are background threads that do not prevent the Java Virtual Machine (JVM) from exiting. If only daemon threads are running, the JVM will exit.

To set a thread as a daemon thread, use the `setDaemon(true)` method on the `Thread` object before calling `start()`.

**Example:**
```java
Thread thread = new Thread(myRunnable);
thread.setDaemon(true); // This thread will end when the Main thread finishes
thread.start();
```

### Terminating Threads
**Normal Completion:** A thread terminates naturally when its `run()` method finishes execution.

**System.exit(int status):** This method can be called from within a thread's `run()` method to prematurely terminate the entire program. A status code of `0` typically indicates successful execution.

## Why Threading is Useful: An Example Scenario
Consider a scenario where a user has a limited time (e.g., 10 seconds) to enter their name.

**Without Threading:** If the timer logic (e.g., a for loop with `Thread.sleep()`) is placed directly in the main method, the program will execute sequentially. This means the user cannot enter their name until the timer loop has completed, which defeats the purpose of a time limit for user input.

**With Threading:**
1. The timer logic is placed in the `run()` method of a `Runnable` object.
2. This `Runnable` is used to create and start a new `Thread`.
3. The main thread continues to execute, prompting the user for input using `Scanner`.
4. The two threads (the timer thread and the main thread) run concurrently.
5. If the user enters their name before the timer runs out, the main thread finishes its task.
6. If the timer thread finishes first, it can print "Times up!" or even terminate the program using `System.exit()`.
7. If the timer thread is set as a daemon thread, it will automatically terminate when the main thread finishes, regardless of whether the timer completed.

This concurrent execution allows the program to handle the timer and user input simultaneously, creating a more responsive and interactive experience.

---

## Activities

### Activity 1: File Download Simulator
Create a program that simulates downloading multiple files concurrently:
1. Create a `DownloadTask` class that implements `Runnable`
2. Each task should simulate downloading a file with a random size (takes 2-5 seconds)
3. Display progress for each download separately
4. Start 3-5 download threads simultaneously
5. When all downloads complete, display "All downloads finished"

### Activity 2: Bank Account Transaction System
Create a banking simulation with multiple accounts:
1. Create a `BankAccount` class with `deposit()` and `withdraw()` methods
2. Create multiple threads that perform random transactions on shared accounts
3. Use `synchronized` keyword to prevent race conditions
4. Track total transactions and final balances
5. Simulate 10 threads making 100 transactions each

### Activity 3: Producer-Consumer Problem
Implement the classic producer-consumer pattern:
1. Create a shared `Buffer` class with fixed capacity
2. Create `Producer` threads that add items to the buffer
3. Create `Consumer` threads that remove items from the buffer
4. Use `wait()` and `notify()` for thread coordination
5. Ensure producers wait when buffer is full, consumers wait when buffer is empty
6. Run simulation with 2 producers and 3 consumers for 100 items
