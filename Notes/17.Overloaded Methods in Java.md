# Overloaded Methods in Java

## Introduction to Overloaded Methods

Overloaded methods in Java allow you to define multiple methods within the same class that share the same name but have different parameter lists. This feature enhances code readability and flexibility by providing a way to perform similar operations with varying input types or quantities.

---

## Method Signature

A method's signature is a unique identifier that distinguishes it from other methods. In Java, the method signature is composed of two parts:

1. **Method Name:** The name given to the method.
2. **Parameters:** The type, order, and number of parameters the method accepts.

**Key Principle:** No two methods within the same class can have the same method signature. However, they can share the same method name as long as their parameter lists differ.

---

## Why Use Overloaded Methods?

Overloaded methods are useful when you want to perform a similar action but with different inputs. For instance, you might have a method to add numbers. You could overload this method to:

- Add two numbers.
- Add three numbers.
- Add four numbers.

The compiler will determine which overloaded method to call based on the arguments provided during the method invocation.

---

## How Overloading Works: Examples

### Example 1: Adding Numbers

Let's consider a scenario where we want to add numbers.

**Scenario:** We need a method to add two numbers.

```java
static double add(double a, double b) {
    return a + b;
}
```

If we try to call `add(1.0, 2.0, 3.0)`, Java will raise an error because there is no `add` method that accepts three double arguments.

**Solution:** We can overload the `add` method to handle three numbers.

```java
static double add(double a, double b, double c) {
    return a + b + c;
}
```

Now, we can call `add(1.0, 2.0)` and `add(1.0, 2.0, 3.0)` separately, and Java will correctly invoke the appropriate `add` method based on the number of arguments provided.

**Illustrative Calls:**

- `add(1.0, 2.0)` would execute the `add(double a, double b)` method.
- `add(1.0, 2.0, 3.0)` would execute the `add(double a, double b, double c)` method.

**Attempting to Overload with Identical Signatures:**

If you attempt to create two methods with the exact same name and the exact same parameter list, Java will produce an error. For example, having two `add(double a, double b)` methods would result in an "already defined" error.

```java
// This will cause a compile-time error:
// static double add(double x, double y) {
//     return x + y;
// }
```

---

### Example 2: Baking a Pizza

This example demonstrates overloading with different parameter types and quantities.

**Base Method (only bread type):**

```java
static String bakePizza(String bread) {
    return bread + " pizza";
}
// Call: bakePizza("flat-bread")
// Output: "flat-bread pizza"
```

**Overloaded Method (bread and cheese):**

```java
static String bakePizza(String bread, String cheese) {
    return cheese + " " + bread + " pizza";
}
// Call: bakePizza("flat-bread", "mozzarella")
// Output: "mozzarella flat-bread pizza"
```

**Overloaded Method (bread, cheese, and topping):**

```java
static String bakePizza(String bread, String cheese, String topping) {
    return topping + " " + cheese + " " + bread + " pizza";
}
// Call: bakePizza("flat-bread", "mozzarella", "pepperoni")
// Output: "pepperoni mozzarella flat-bread pizza"
```

In this pizza example, the `bakePizza` method is overloaded three times. Each version accepts a different combination of parameters, allowing for flexibility in describing the pizza being "baked." When you call `bakePizza` with specific arguments, Java matches the call to the method with the most appropriate parameter list.

---

## Key Takeaways

1. **Same Name, Different Parameters:** Overloaded methods share a name but must differ in the number, type, or order of their parameters.
2. **Unique Signatures:** The combination of a method's name and its parameter list creates a unique method signature.
3. **Compiler's Role:** The Java compiler determines which overloaded method to execute based on the arguments provided in the method call.
4. **Readability and Reusability:** Overloading promotes cleaner code by allowing related operations to be represented by a single, intuitive method name.

---

# Overloaded Methods Activities

## Activity 1: Smart Calculator with Maximum Overloading
Create a calculator that uses overloaded methods for different types of calculations:

**Overloading Challenge:**
1. **Addition Methods:**
   - `add(int a, int b)`
   - `add(double a, double b)`
   - `add(int a, int b, int c)`
   - `add(double a, double b, double c)`
   - `add(int[] numbers)` - sums all numbers in array
   - `add(double[] numbers)` - sums all doubles in array

2. **Multiplication Methods:**
   - `multiply(int a, int b)`
   - `multiply(double a, double b)`
   - `multiply(int a, int b, int c)`
   - `multiply(int[] numbers)` - product of all numbers
   - `multiply(String text, int times)` - repeats string

3. **Formatting Methods:**
   - `format(double number)` - returns formatted string with 2 decimals
   - `format(double number, int decimals)` - specified decimal places
   - `format(double number, int decimals, String currency)` - adds currency symbol
   - `format(double number, boolean useCommas)` - adds thousand separators

**Program Requirements:**
- Use method overloading wherever possible
- Create a menu to test all overloaded versions
- Handle edge cases (empty arrays, negative numbers, etc.)
- Demonstrate how Java selects the correct overloaded method

**Test Cases:**
```
Input: add(5, 3) → Output: 8
Input: add(5.5, 2.3) → Output: 7.8
Input: add(1, 2, 3, 4, 5) → Output: 15
Input: multiply(3, 4) → Output: 12
Input: multiply("Hello", 3) → Output: "HelloHelloHello"
```

## Activity 2: Shape Area Calculator with Constructor Overloading
Create a shape calculator that uses overloaded constructors and methods:

**Shape Classes:**
1. **Rectangle Class:**
   - Constructor overloads: `Rectangle()`, `Rectangle(double side)`, `Rectangle(double length, double width)`
   - Method overloads: `area()`, `area(double scaleFactor)`, `area(String unit)`
   
2. **Circle Class:**
   - Constructor overloads: `Circle()`, `Circle(double radius)`
   - Method overloads: `area()`, `circumference()`, `area(boolean includeCircumference)`
   
3. **Triangle Class:**
   - Constructor overloads: `Triangle()`, `Triangle(double base, double height)`, `Triangle(double side1, double side2, double side3)`
   - Method overloads: `area()`, `perimeter()`, `area(String type)` - for different triangle types

**Advanced Features:**
1. **Compound Shapes:** Overloaded methods for combined shapes
   - `area(Rectangle r, Circle c)` - area of rectangle with circular cutout
   - `area(Circle c1, Circle c2)` - overlapping circles area
   
2. **Unit Conversion:** Overloaded methods for different units
   - `areaInMeters()`, `areaInFeet()`, `areaInInches()`
   
3. **Display Methods:** Multiple ways to display results
   - `display()`, `display(boolean verbose)`, `display(String format)`

**Example Usage:**
```java
Rectangle r1 = new Rectangle(); // default 1x1
Rectangle r2 = new Rectangle(5); // square 5x5
Rectangle r3 = new Rectangle(4, 6); // rectangle 4x6

System.out.println(r1.area()); // 1.0
System.out.println(r2.area("cm²")); // "25.0 cm²"
System.out.println(r3.area(2.0)); // scaled area
```

## Activity 3: Data Parser with Multiple Input Formats
Create a data parser that can handle input in various formats using overloaded methods:

**Parsing Methods Overloads:**
1. **Parse Numbers:**
   - `parse(String input)` - tries to parse as int, then double
   - `parse(String input, int radix)` - parse with different base
   - `parse(String input, boolean strict)` - throws exception if invalid
   - `parse(String[] inputs)` - parses array of strings

2. **Parse Dates:**
   - `parseDate(String date)` - tries common formats
   - `parseDate(String date, String format)` - specific format
   - `parseDate(int year, int month, int day)`
   - `parseDate(long timestamp)`

3. **Parse Coordinates:**
   - `parseCoordinate(String coord)` - "40.7128,-74.0060"
   - `parseCoordinate(double lat, double lon)`
   - `parseCoordinate(String dmsLat, String dmsLon)` - Degrees/Minutes/Seconds
   - `parseCoordinate(int[] degrees)` - [40, 42, 51] format

4. **Parse Person Information:**
   - `parsePerson(String name)` - just name
   - `parsePerson(String name, int age)`
   - `parsePerson(String name, int age, String email)`
   - `parsePerson(String csvLine)` - "John Doe,30,john@email.com"
   - `parsePerson(JSONObject json)` - from JSON format

**Program Features:**
- Create a unified `DataParser` class with all overloaded methods
- Implement intelligent parsing that tries multiple formats
- Add validation methods with different error handling options
- Create conversion methods between different formats
- Handle edge cases gracefully

**Example Test:**
```java
DataParser parser = new DataParser();

// All these should work with different parse methods:
String date1 = "2023-12-25";
String date2 = "12/25/2023";
String date3 = "Dec 25, 2023";

parser.parseDate(date1); // uses default format
parser.parseDate(date2, "MM/dd/yyyy"); // specific format
parser.parseDate(2023, 12, 25); // separate parameters

// Coordinate parsing:
parser.parseCoordinate("40.7128° N, 74.0060° W");
parser.parseCoordinate(40.7128, -74.0060);
parser.parseCoordinate("40°42'51\" N", "74°0'21\" W");
```
