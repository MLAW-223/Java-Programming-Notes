# Overloaded Constructors in Java

## What are Overloaded Constructors?
Overloaded constructors are a powerful feature in Java that allow a class to have multiple constructors, each with a different parameter list. This is similar to method overloading, where you can have multiple methods with the same name but different parameters.

The primary purpose of overloaded constructors is to enable objects of a class to be initialized in various ways. This is particularly useful when some attributes of an object are optional.

## Why Use Overloaded Constructors?
- **Flexibility in Object Initialization:** You can create objects with different sets of initial data.
- **Handling Optional Attributes:** If certain properties of an object don't always need to be provided at creation, overloaded constructors can provide default values for those missing attributes.
- **Code Readability:** By having constructors that clearly define what data is being used for initialization, your code can become more understandable.

## How to Implement Overloaded Constructors
To implement overloaded constructors, you define multiple constructors within a class. Each constructor must have a unique signature, meaning it must differ in the number or type of its parameters.

### Example: The User Class
Let's consider the User class from the provided material. This class has attributes for username, email, and age.

```java
public class User {
    String username;
    String email;
    int age;

    // Constructor 1: No arguments (default values)
    User() {
        this.username = "Guest";
        this.email = "Not provided";
        this.age = 0;
    }

    // Constructor 2: Username only
    User(String username) {
        this.username = username;
        this.email = "Not provided"; // Default value for email
        this.age = 0;               // Default value for age
    }

    // Constructor 3: Username and Email
    User(String username, String email) {
        this.username = username;
        this.email = email;
        this.age = 0;               // Default value for age
    }

    // Constructor 4: Username, Email, and Age
    User(String username, String email, int age) {
        this.username = username;
        this.email = email;
        this.age = age;
    }
}
```

## Creating Objects with Overloaded Constructors
In the main method, you can create User objects using these different constructors:

```java
public class Main {
    public static void main(String[] args) {
        // Using Constructor 4 (all parameters)
        User user3 = new User("Sandy", "SCheeks@gmail.com", 27);
        System.out.println("User 3:");
        System.out.println("Username: " + user3.username); // Output: Sandy
        System.out.println("Email: " + user3.email);       // Output: SCheeks@gmail.com
        System.out.println("Age: " + user3.age);           // Output: 27

        // Using Constructor 3 (username and email)
        User user2 = new User("Patrick", "PStar@aol.com");
        System.out.println("\nUser 2:");
        System.out.println("Username: " + user2.username); // Output: Patrick
        System.out.println("Email: " + user2.email);       // Output: PStar@aol.com
        System.out.println("Age: " + user2.age);           // Output: 0 (default)

        // Using Constructor 2 (username only)
        User user1 = new User("Spongebob");
        System.out.println("\nUser 1:");
        System.out.println("Username: " + user1.username); // Output: Spongebob
        System.out.println("Email: " + user1.email);       // Output: Not provided (default)
        System.out.println("Age: " + user1.age);           // Output: 0 (default)

        // Using Constructor 1 (no arguments)
        User user4 = new User();
        System.out.println("\nUser 4:");
        System.out.println("Username: " + user4.username); // Output: Guest (default)
        System.out.println("Email: " + user4.email);       // Output: Not provided (default)
        System.out.println("Age: " + user4.age);           // Output: 0 (default)
    }
}
```

## Key Concepts
- **Constructor Signature:** The combination of the constructor name and its parameter list. For overloading, each constructor must have a unique signature.
- **this Keyword:** Used within a constructor to refer to the current object's instance variables. This helps distinguish between the instance variables and the parameters passed to the constructor.
- **Default Values:** Overloaded constructors can be used to assign default values to attributes when those attributes are not provided during object creation.

## Analogy to Method Overloading
Just as overloaded methods allow a class to perform similar operations with different inputs, overloaded constructors allow a class to be instantiated with different initial states. The core principle is the same: multiple methods/constructors with the same name but distinct parameter lists.

## Constructor Overloading Rules
1. **Different Parameter Count:** Constructors must differ in the number of parameters
2. **Different Parameter Types:** If same number of parameters, they must differ in parameter types
3. **Different Parameter Order:** The order of parameters can also differentiate constructors
4. **Same Name:** All constructors must have the same name as the class

## Best Practices for Overloaded Constructors

### 1. Constructor Chaining
Use `this()` to call other constructors within the same class to avoid code duplication:

```java
public class User {
    String username;
    String email;
    int age;

    // Constructor 1: No arguments
    User() {
        this("Guest", "Not provided", 0); // Calls Constructor 4
    }

    // Constructor 2: Username only
    User(String username) {
        this(username, "Not provided", 0); // Calls Constructor 4
    }

    // Constructor 3: Username and Email
    User(String username, String email) {
        this(username, email, 0); // Calls Constructor 4
    }

    // Constructor 4: All parameters (main constructor)
    User(String username, String email, int age) {
        this.username = username;
        this.email = email;
        this.age = age;
    }
}
```

### 2. Parameter Validation
Always validate parameters in constructors:

```java
public class Account {
    String accountNumber;
    double balance;
    
    Account(String accountNumber, double balance) {
        if (accountNumber == null || accountNumber.isEmpty()) {
            throw new IllegalArgumentException("Account number cannot be null or empty");
        }
        if (balance < 0) {
            throw new IllegalArgumentException("Balance cannot be negative");
        }
        this.accountNumber = accountNumber;
        this.balance = balance;
    }
}
```

### 3. Use Sensible Defaults
Provide reasonable default values in constructors with fewer parameters:

```java
public class Product {
    String name;
    double price;
    int quantity;
    String category;
    
    // Basic product with default category
    Product(String name, double price) {
        this(name, price, 1, "General");
    }
    
    // Full constructor
    Product(String name, double price, int quantity, String category) {
        this.name = name;
        this.price = price;
        this.quantity = quantity;
        this.category = category;
    }
}
```

## Common Mistakes to Avoid

1. **Duplicate Constructors:** Having constructors with the exact same parameter types and count
2. **Infinite Recursion:** Using `this()` incorrectly causing constructor to call itself
3. **Forgetting `this()` Call:** The call to another constructor must be the first statement
4. **Overcomplicating:** Too many constructors can make code confusing

## Practical Applications

### 1. Database Entities
```java
public class Customer {
    int id;
    String name;
    String email;
    String phone;
    LocalDate joinDate;
    
    // For new customer creation
    Customer(String name, String email) {
        this(0, name, email, null, LocalDate.now());
    }
    
    // For database retrieval
    Customer(int id, String name, String email, String phone, LocalDate joinDate) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.phone = phone;
        this.joinDate = joinDate;
    }
}
```

### 2. Configuration Objects
```java
public class Configuration {
    String host;
    int port;
    boolean ssl;
    int timeout;
    
    // Minimal configuration
    Configuration(String host) {
        this(host, 80, false, 30);
    }
    
    // Standard configuration
    Configuration(String host, int port) {
        this(host, port, false, 30);
    }
    
    // Full configuration
    Configuration(String host, int port, boolean ssl, int timeout) {
        this.host = host;
        this.port = port;
        this.ssl = ssl;
        this.timeout = timeout;
    }
}
```

### 3. API Request Objects
```java
public class SearchRequest {
    String query;
    int page;
    int limit;
    String sortBy;
    boolean ascending;
    
    // Quick search
    SearchRequest(String query) {
        this(query, 1, 10, "relevance", true);
    }
    
    // Advanced search
    SearchRequest(String query, int page, int limit, String sortBy, boolean ascending) {
        this.query = query;
        this.page = page;
        this.limit = limit;
        this.sortBy = sortBy;
        this.ascending = ascending;
    }
}
```

## Constructor vs Method Overloading
| Feature | Constructor Overloading | Method Overloading |
|---------|------------------------|-------------------|
| **Purpose** | Initialize objects | Perform operations |
| **Return Type** | None | Required |
| **Name** | Same as class | Any valid identifier |
| **Invocation** | With `new` keyword | Direct call |

---

## Activities

### Activity 1: Smartphone Class with Overloaded Constructors
Create a `Smartphone` class with:
1. **Attributes:** brand, model, storageGB, ramGB, color, price
2. **Constructors:**
   - No-argument constructor with default values
   - Constructor with just brand and model
   - Constructor with brand, model, and storage
   - Constructor with brand, model, storage, and RAM
   - Full constructor with all parameters
3. **Methods:** displaySpecs(), calculateDiscountedPrice(discountPercentage)
4. Create 5 smartphone objects using different constructors
5. Display specifications and test discount calculations

### Activity 2: Bank Account System with Multiple Constructors
Create a `BankAccount` class with:
1. **Attributes:** accountNumber, accountHolder, accountType, balance, interestRate, isActive
2. **Constructors:**
   - For new customers: accountHolder only (generate account number)
   - For existing customers: accountNumber and accountHolder
   - Full account creation: all parameters
   - Savings account constructor: accountHolder and initial deposit
   - Checking account constructor: accountHolder with overdraft protection
3. **Methods:**
   - deposit(amount)
   - withdraw(amount) with validation
   - calculateInterest() (if applicable)
   - getAccountSummary()
4. Test all constructor variations and account operations

### Activity 3: E-commerce Product System
Create a `Product` class with:
1. **Attributes:** productId, name, description, price, category, stockQuantity, manufacturer, weight, dimensions
2. **Constructors:**
   - Quick add: name and price only
   - Basic product: name, price, category
   - Detailed product: name, description, price, category
   - Full product: all attributes
   - Copy constructor: create a variant of existing product
3. **Methods:**
   - applyDiscount(percentage)
   - updateStock(quantity)
   - isInStock()
   - calculateShippingCost()
   - displayFullDetails()
4. Create a product catalog using different constructors
5. Implement product search and filtering functionality
