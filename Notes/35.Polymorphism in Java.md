# Polymorphism in Java

## Introduction to Polymorphism
Polymorphism is a fundamental concept in object-oriented programming that allows objects to be treated as instances of their superclass or interface. The word "polymorphism" originates from Greek words: "poly" meaning "many" and "morph" meaning "shape." Therefore, polymorphism essentially means "many shapes" or "many forms."

This means that objects can identify as themselves but also as other types of objects, specifically those that are related to them through inheritance or interface implementation. The key idea is that objects can be treated as objects of a common superclass or interface.

## Core Concepts
**"Many Shapes":** Objects can take on multiple forms or identities.

**"Objects can identify as other objects":** An object of a specific class can also be identified as an instance of its superclass or an interface it implements.

**"Objects can be treated as objects of a common superclass/interface":** This is the practical application. You can use a variable of a superclass type to refer to an object of a subclass, or a variable of an interface type to refer to an object that implements that interface.

## How Polymorphism is Achieved in Java
Polymorphism in Java can be achieved through two primary mechanisms:

**Inheritance:** When a class extends another class, the subclass inherits the methods and properties of the superclass. A subclass object can be treated as an object of its superclass.

**Interfaces:** When a class implements an interface, it promises to provide implementations for the methods declared in that interface. An object of a class that implements an interface can be treated as an object of that interface type.

## Example: Inheritance
Let's consider a scenario with a `Vehicle` superclass and several subclasses like `Car`, `Bike`, and `Boat`.

**Superclass: Vehicle**
The `Vehicle` class can be an abstract class, meaning you cannot create direct instances of `Vehicle`. It defines common behaviors that all vehicles should have.

```java
public abstract class Vehicle {
    abstract void go(); // Abstract method: all vehicles must have a 'go' method
}
```

**Subclasses: Car, Bike, Boat**
These classes extend `Vehicle` and provide their specific implementations for the `go()` method.

```java
public class Car extends Vehicle {
    @Override
    void go() {
        System.out.println("You drive the car");
    }
}

public class Bike extends Vehicle {
    @Override
    void go() {
        System.out.println("You ride the bike");
    }
}

public class Boat extends Vehicle {
    @Override
    void go() {
        System.out.println("You sail the boat");
    }
}
```

## Demonstrating Polymorphism with Inheritance
In the `main` method, we can create objects of `Car`, `Bike`, and `Boat`. The key is that we can store these objects in an array whose type is the common superclass, `Vehicle`.

```java
public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        Bike bike = new Bike();
        Boat boat = new Boat();

        // Polymorphism in action:
        // An array of Vehicle can hold objects of Car, Bike, and Boat
        Vehicle[] vehicles = {car, bike, boat};

        // We can iterate through the array and call the 'go()' method on each object.
        // Even though the array is of type Vehicle, the actual object's 'go()' method is called.
        for (Vehicle vehicle : vehicles) {
            vehicle.go(); // This will call the specific implementation (Car's go, Bike's go, Boat's go)
        }
    }
}
```

**Output:**
```
You drive the car
You ride the bike
You sail the boat
```

**Explanation:**
When `vehicle.go()` is called inside the loop, Java determines which specific `go()` method to execute based on the actual type of the object (`Car`, `Bike`, or `Boat`) that `vehicle` currently refers to at runtime. This is known as dynamic method dispatch or late binding.

## Example: Interfaces
Polymorphism can also be achieved using interfaces.

**Interface: Vehicle**
```java
public interface Vehicle {
    void go(); // Methods in interfaces are implicitly public and abstract
}
```

**Implementing Classes: Car, Bike, Boat**
These classes now implement the `Vehicle` interface and must provide an implementation for the `go()` method.

```java
public class Car implements Vehicle {
    @Override
    public void go() {
        System.out.println("You drive the car");
    }
}

public class Bike implements Vehicle {
    @Override
    public void go() {
        System.out.println("You ride the bike");
    }
}

public class Boat implements Vehicle {
    @Override
    public void go() {
        System.out.println("You sail the boat");
    }
}
```

## Demonstrating Polymorphism with Interfaces
Similar to the inheritance example, we can create an array of the interface type `Vehicle` and store objects of classes that implement this interface.

```java
public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        Bike bike = new Bike();
        Boat boat = new Boat();

        // Polymorphism in action:
        // An array of Vehicle (interface) can hold objects of Car, Bike, and Boat
        Vehicle[] vehicles = {car, car, boat}; // Note: can even hold multiple Car objects

        for (Vehicle vehicle : vehicles) {
            vehicle.go(); // Calls the specific implementation based on the object's actual type
        }
    }
}
```

**Output:**
```
You drive the car
You drive the car
You sail the boat
```

**Explanation:**
The principle is the same as with inheritance. The `vehicle.go()` call invokes the `go()` method of the object's actual class at runtime. Using interfaces is often preferred for achieving polymorphism when you want to define a contract without providing any implementation, allowing unrelated classes to share a common method signature.

---

## Activities

### Activity 1: Shape Polymorphism
Create an abstract class `Shape` with an abstract method `draw()`. Create three subclasses: `Circle`, `Rectangle`, and `Triangle`. Each should implement the `draw()` method to print a specific message (e.g., "Drawing a circle"). In the `main` method, create an array of `Shape` objects containing instances of each subclass and call the `draw()` method on each using a loop.

### Activity 2: Animal Interface Polymorphism
Create an interface `Animal` with methods `makeSound()` and `move()`. Create three classes: `Dog`, `Bird`, and `Fish` that implement this interface. Each class should provide unique implementations for both methods. In the `main` method, create an ArrayList of `Animal` objects, add instances of all three classes, and iterate through the list to call both methods on each object.

### Activity 3: Payment System Polymorphism
Design a payment system with an interface `PaymentMethod` with method `pay(double amount)`. Create three classes: `CreditCard`, `PayPal`, and `BankTransfer` that implement this interface. Each should print a unique message when processing a payment. In the `main` method, create a method called `processPayment(PaymentMethod method, double amount)` that accepts any payment method and processes the payment. Test it with all three payment types.
