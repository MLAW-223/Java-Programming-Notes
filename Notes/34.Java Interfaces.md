# Java Interfaces

## What is an Interface?
An interface in Java is a blueprint for a class. It defines a set of abstract methods that any class implementing the interface must define. Think of it as a contract that a class agrees to fulfill.

## Key Characteristics of Interfaces
**Abstract Methods:** Interfaces primarily contain abstract methods, meaning these methods have a signature but no implementation (body). The implementing class is responsible for providing the concrete implementation.

**Multiple Inheritance-Like Behavior:** While a Java class can only extend one parent class (single inheritance), it can implement multiple interfaces. This allows a class to inherit behaviors from several different sources, mimicking multiple inheritance.

**Blueprint for Behavior:** Interfaces specify what a class should do, not how it should do it. This separates the contract from the implementation.

## Creating an Interface
To create an interface, you use the `interface` keyword.

```java
public interface Prey {
    void flee(); // Abstract method declaration
}

public interface Predator {
    void hunt(); // Abstract method declaration
}
```

In the example above:
- `Prey` is an interface with a single abstract method `flee()`.
- `Predator` is an interface with a single abstract method `hunt()`.

## Implementing an Interface
A class implements an interface using the `implements` keyword. If a class implements an interface, it must provide a concrete implementation for all abstract methods declared in that interface.

```java
public class Rabbit implements Prey {
    @Override
    public void flee() {
        System.out.println("*The rabbit is running away*");
    }
}
```

In this `Rabbit` class:
- It implements `Prey`, agreeing to provide a definition for the `flee()` method.
- The `@Override` annotation is used to indicate that this method is intended to override a method from a superclass or interface.
- The `flee()` method is defined with a public access modifier and provides the specific behavior for a rabbit fleeing.

## Implementing Multiple Interfaces
A class can implement more than one interface, allowing it to adopt behaviors from multiple contracts.

```java
public class Fish implements Prey, Predator {

    @Override
    public void flee() {
        System.out.println("*The fish is swimming away*");
    }

    @Override
    public void hunt() {
        System.out.println("*The fish is hunting*");
    }
}
```

The `Fish` class implements both `Prey` and `Predator`. Therefore, it must provide implementations for both `flee()` and `hunt()`.

## Using Interfaces in Code
You can create objects of classes that implement interfaces and call the methods defined in those interfaces.

```java
public class Main {
    public static void main(String[] args) {
        Rabbit rabbit = new Rabbit();
        Hawk hawk = new Hawk();
        Fish fish = new Fish();

        rabbit.flee(); // Calls the flee() method defined in Rabbit
        hawk.hunt();   // Calls the hunt() method defined in Hawk
        fish.flee();   // Calls the flee() method defined in Fish
        fish.hunt();   // Calls the hunt() method defined in Fish
    }
}

// Assuming Hawk class implements Predator:
public class Hawk implements Predator {
    @Override
    public void hunt() {
        System.out.println("*The hawk is hunting*");
    }
}
```

## Interfaces vs. Abstract Classes
There is overlap between interfaces and abstract classes, but key differences exist:

**Inheritance:**
- A class can extend only one abstract class (single inheritance of implementation).
- A class can implement multiple interfaces (multiple inheritance of type/contract).

**Fields:**
- Abstract classes can have instance variables (fields) of any type and access modifier.
- Interfaces, by default, have only public static final fields (constants).

**Methods:**
- Abstract classes can have abstract methods, concrete methods, and static methods.
- Interfaces traditionally only had abstract methods. However, since Java 8, they can also contain default and static methods with implementations.

While both can be used to define a common type or blueprint, interfaces are generally used to define a contract or a capability, whereas abstract classes are used to define a base type with shared implementation or state.

---

## Activities

### Activity 1: Basic Interface Implementation
Create a `Vehicle` interface with methods `start()` and `stop()`. Then create a `Car` class that implements this interface. In the `main` method, create a `Car` object and call both methods.

### Activity 2: Multiple Interface Implementation
Create two interfaces: 
1. `Flyable` with method `fly()`
2. `Swimmable` with method `swim()`

Create a `Duck` class that implements both interfaces. Implement the methods to print appropriate messages. Test your implementation in a `main` method.

### Activity 3: Interface Design Challenge
Design a simple media player system with the following interfaces:
- `Playable` with methods `play()`, `pause()`, and `stop()`
- `VolumeControl` with methods `volumeUp()` and `volumeDown()`

Create two classes:
1. `AudioPlayer` that implements both interfaces
2. `VideoPlayer` that implements only `Playable` interface

Demonstrate polymorphism by creating objects and calling their methods through interface references.
