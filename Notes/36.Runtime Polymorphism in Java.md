# Runtime Polymorphism in Java

## What is Runtime Polymorphism?
Runtime polymorphism, also known as dynamic polymorphism, occurs when the method that is executed is determined at runtime based on the actual type of the object. This is in contrast to compile-time polymorphism (like method overloading), where the method to be called is decided during compilation.

## Key Concepts and Implementation
The core idea behind runtime polymorphism is to allow a superclass reference to refer to a subclass object. When a method is called on this superclass reference, the version of the method that gets executed is the one defined in the subclass, provided the subclass has overridden that method.

**Inheritance:** Runtime polymorphism heavily relies on inheritance. A subclass inherits methods and properties from its superclass.

**Method Overriding:** To achieve runtime polymorphism, subclasses must override methods from their superclass. Method overriding means that a subclass provides a specific implementation for a method that is already defined in its superclass. The method signature (name, return type, and parameters) must be the same in both the superclass and the subclass.

## Abstract Classes and Methods
While not strictly required for runtime polymorphism, abstract classes and abstract methods are often used in conjunction with it.

**Abstract Class:** A class that cannot be instantiated. It is declared using the `abstract` keyword. Abstract classes are meant to be extended by other classes.

**Abstract Method:** A method declared without an implementation (no method body). It is declared using the `abstract` keyword. Any class that extends an abstract class must provide an implementation for all of its abstract methods, unless the subclass is also declared as abstract.

**Example:**
In the provided materials, an `Animal` class is declared as abstract with an abstract `speak()` method. This prevents direct instantiation of `Animal` objects and enforces that any concrete subclass must provide its own `speak()` implementation.

```java
// Abstract superclass
abstract class Animal {
    abstract void speak(); // Abstract method
}
```

## Polymorphic Behavior in Action
The power of runtime polymorphism lies in treating objects of different subclasses uniformly through a superclass reference.

**Example Scenario:**
1. **Define Classes:**
   - `Animal` (abstract class with abstract `speak()` method)
   - `Dog` (extends `Animal`, overrides `speak()` to output "woof")
   - `Cat` (extends `Animal`, overrides `speak()` to output "meow")

2. **Declare a Superclass Reference:** Declare a variable of the superclass type (`Animal`) but do not instantiate it yet.
   ```java
   Animal animal;
   ```

3. **Instantiate Subclass Objects Based on Runtime Conditions:** At runtime, based on user input or other conditions, create an instance of a specific subclass and assign it to the superclass reference.
   ```java
   if (choice == 1) {
       animal = new Dog(); // animal reference now points to a Dog object
   } else if (choice == 2) {
       animal = new Cat(); // animal reference now points to a Cat object
   }
   ```

4. **Invoke the Overridden Method:** Call the method (`speak()`) on the superclass reference. The JVM determines which `speak()` method to execute based on the actual type of the object the `animal` reference is currently pointing to.
   ```java
   animal.speak(); // This will call Dog's speak() if animal is a Dog,
                   // or Cat's speak() if animal is a Cat.
   ```

## Code Example Breakdown
The provided `Main` class demonstrates runtime polymorphism:

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // Runtime polymorphism = When the method that gets executed is decided
        // at runtime based on the actual type of the object.

        Scanner scanner = new Scanner(System.in);

        Animal animal; // Declare a superclass reference

        System.out.print("Would you like a dog or a cat? (1 = dog, 2 = cat): ");
        int choice = scanner.nextInt();

        if(choice == 1){
            // Instantiate a Dog object and assign it to the Animal reference
            animal = new Dog();
            animal.speak(); // Calls Dog's speak() method
        }
        else if(choice == 2){
            // Instantiate a Cat object and assign it to the Animal reference
            animal = new Cat();
            animal.speak(); // Calls Cat's speak() method
        }
        // Note: An else block could handle invalid input, but is omitted for brevity.

        scanner.close(); // Good practice to close the scanner
    }
}

// Assume Dog and Cat classes exist as described above, extending Animal and overriding speak()
```

## Benefits of Runtime Polymorphism
**Flexibility and Extensibility:** New subclasses can be added without modifying the existing code that uses the superclass reference. The code will automatically work with the new types.

**Code Reusability:** Allows for writing generic code that can operate on a variety of object types.

**Decoupling:** Reduces the tight coupling between different parts of the program.

In essence, runtime polymorphism allows you to write code that is more adaptable and easier to maintain, especially in larger and evolving systems.

---

## Activities

### Activity 1: Employee Salary System
Create an abstract class `Employee` with abstract method `calculateSalary()`. Create three subclasses: `FullTimeEmployee` (salary = fixed monthly), `PartTimeEmployee` (salary = hours Ã— rate), and `Contractor` (salary = project amount). Use runtime polymorphism to calculate and display salaries for different types of employees based on user input.

### Activity 2: Notification System
Create an abstract class `Notification` with abstract method `send()`. Create subclasses: `EmailNotification`, `SMSNotification`, and `PushNotification`. Each should implement `send()` with appropriate messages. In the `main` method, ask the user what type of notification they want to send, then use runtime polymorphism to create and send the appropriate notification.

### Activity 3: Database Connection Manager
Create an abstract class `DatabaseConnection` with abstract methods `connect()` and `disconnect()`. Create subclasses: `MySQLConnection`, `PostgreSQLConnection`, and `OracleConnection`. Each should implement these methods with specific database messages. In the `main` method, demonstrate runtime polymorphism by allowing the user to select a database type and then performing connection and disconnection operations.
