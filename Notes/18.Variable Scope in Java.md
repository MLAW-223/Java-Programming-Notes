# Variable Scope in Java

## Introduction to Variable Scope

Variable scope refers to the region or context within a program where a variable is accessible and can be used. In Java, there are two primary levels of variable scope discussed: **local scope** and **class scope**.

---

## Local Scope

Variables declared **inside a method** have a **local scope**. This means they are only recognized and accessible within the specific method in which they are declared.

**Characteristics:**
- **Declaration:** Declared within a method's curly braces `{}`.
- **Accessibility:** Accessible only within the declaring method.
- **Independence:** Other methods cannot directly access variables declared in a different method's local scope. If another method needs to use such a variable, it must be passed as an argument.
- **Naming:** It is legal to declare variables with the same name in different methods, as long as they are within their respective local scopes. Java treats them as distinct variables.

**Example:**

In the `main` method, `int x = 1;` declares a local variable `x` with a value of 1. This `x` is only accessible within `main`. The `doSomething` method also declares a local variable `int x = 2;`. This `x` is only accessible within `doSomething`.

```java
public class Main {

    public static void main(String[] args) {
        int x = 1; // Local scope in main
        System.out.println(x); // Prints 1
        doSomething();
    }

    static void doSomething() {
        int x = 2; // Local scope in doSomething
        System.out.println(x); // Prints 2
    }
}
```

In this example:
- When `System.out.println(x)` is called within `main`, it prints the value of `main`'s local `x`, which is 1.
- When `doSomething()` is called, and `System.out.println(x)` is executed within `doSomething`, it prints the value of `doSomething`'s local `x`, which is 2.

---

## Class Scope

Class variables, also known as instance variables or member variables, are declared **inside a class but outside of any methods**.

**Characteristics:**
- **Declaration:** Declared directly within the class, but not within any method.
- **Accessibility:** Accessible from **any method** within the same class.
- **Visibility Analogy:** Can be thought of as being "out in the street" – accessible to all "houses" (methods) within the "neighborhood" (class).

**Example:**

```java
public class Main {

    static int x = 3; // Class scope

    public static void main(String[] args) {
        System.out.println(x); // Accesses class scope x
        doSomething();
    }

    static void doSomething() {
        System.out.println(x); // Accesses class scope x
    }
}
```

In this example:
- `static int x = 3;` declares a variable `x` with class scope.
- When `System.out.println(x)` is called within `main`, it prints the value of the class variable `x`, which is 3.
- When `doSomething()` is called, and `System.out.println(x)` is executed within `doSomething`, it also prints the value of the class variable `x`, which is 3.

---

## Interaction Between Local and Class Scope

When a local variable and a class variable share the same name, Java **prioritizes the local variable** within its scope.

**Key Concepts:**
- **Precedence:** If a variable name is declared both locally within a method and as a class variable, the local variable will be used when accessed within that method.
- **"Shadowing":** The local variable "shadows" the class variable.

**Example:**

```java
public class Main {

    static int x = 3; // Class scope

    public static void main(String[] args) {
        int x = 1; // Local scope in main, shadows class scope x
        System.out.println(x); // Prints 1 (local x)
        doSomething();
    }

    static void doSomething() {
        int x = 2; // Local scope in doSomething, shadows class scope x
        System.out.println(x); // Prints 2 (local x)
    }
}
```

In this example:
- Within `main`, `int x = 1;` creates a local variable that takes precedence over the class variable `x`. Thus, `System.out.println(x)` prints 1.
- Within `doSomething`, `int x = 2;` creates another local variable. This local `x` takes precedence over the class variable `x` within `doSomething`. Thus, `System.out.println(x)` prints 2.
- The class variable `x` with the value 3 is not directly accessed by the `println` statements in this specific scenario because local variables with the same name exist and are prioritized.

---

## When to Use Class Variables

While local variables are generally preferred due to their defined scope, class variables can be beneficial in specific situations:

1. **Constants:** When you need to define values that do not change throughout the program (e.g., `final int MAX_VALUE = 100;`).
2. **Object-Oriented Programming:** When working with objects, class variables are essential for storing data that is shared among all instances of a class or is specific to an instance. This is a more advanced topic.

---

# Variable Scope Activities

## Activity 1: Scope Maze Challenge
Create a program that demonstrates different scoping issues and requires students to fix them:

**Scenario 1: Variable Hiding**
```java
public class ScopeChallenge {
    static int count = 0; // Class variable
    
    public static void main(String[] args) {
        int count = 5; // Local variable
        System.out.println("Local count: " + count);
        System.out.println("Class count: " + count); // ERROR: Can't access class variable
        incrementCount();
    }
    
    static void incrementCount() {
        count++; // Which count is this modifying?
        System.out.println("Incremented count: " + count);
    }
}
```

**Tasks:**
1. Fix the code to access the class variable from `main`
2. Add a parameter to `incrementCount` that controls which variable to modify
3. Create a method that returns both the local and class values
4. Demonstrate variable shadowing in nested scopes

**Scenario 2: Loop Variable Scope**
```java
public class LoopScope {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            int temp = i * 2;
            System.out.println(temp);
        }
        // System.out.println(i); // ERROR: i not accessible
        // System.out.println(temp); // ERROR: temp not accessible
    }
}
```

**Tasks:**
1. Move variable declarations to different scopes
2. Create methods that demonstrate proper variable passing
3. Show how to make loop variables accessible outside loops

## Activity 2: Game State Manager
Create a game that manages state using different scopes appropriately:

**Game Requirements:**
1. **Global Game Settings** (Class scope):
   - Game title, version, difficulty levels
   - Maximum players, game time limit
   - Constants like MAX_SCORE, MIN_PLAYERS

2. **Game Session Variables** (Method scope in main):
   - Current players, scores, game time remaining
   - Player names, positions, resources

3. **Method-Specific Variables** (Local scope):
   - Temporary calculations in combat methods
   - Loop counters for rendering
   - Input validation variables

**Implementation Tasks:**
1. Create a `GameSettings` class with class variables
2. Implement a `startGame()` method with its own local variables
3. Create helper methods like `calculateDamage()`, `updateScore()` that use:
   - Parameters for input
   - Local variables for calculations
   - Return values for output
4. Demonstrate when to use each scope type

**Example Structure:**
```java
public class GameManager {
    // CLASS SCOPE: Game constants
    static final int MAX_PLAYERS = 4;
    static final String VERSION = "1.0";
    
    public static void main(String[] args) {
        // METHOD SCOPE: Game session
        int currentPlayers = 0;
        String[] playerNames = new String[MAX_PLAYERS];
        
        startGame(currentPlayers, playerNames);
    }
    
    static void startGame(int players, String[] names) {
        // LOCAL SCOPE: Game setup
        boolean gameStarted = false;
        
        // More game logic...
    }
    
    static int calculateDamage(int attack, int defense) {
        // LOCAL SCOPE: Calculation only
        int baseDamage = attack - defense;
        int randomFactor = (int)(Math.random() * 10);
        return Math.max(0, baseDamage + randomFactor);
    }
}
```

## Activity 3: Bank Account Simulation with Proper Scoping
Create a bank account system that demonstrates appropriate variable scoping:

**Account Class Design:**
```java
public class BankAccount {
    // CLASS INSTANCE VARIABLES: Account state
    private String accountNumber;
    private double balance;
    private String ownerName;
    
    // CLASS CONSTANTS
    private static final double OVERDRAFT_FEE = 35.00;
    private static final double MINIMUM_BALANCE = 25.00;
    
    // Constructor: Properly initializes instance variables
    public BankAccount(String number, String name, double initialDeposit) {
        this.accountNumber = number; // 'this' clarifies scope
        this.ownerName = name;
        this.balance = initialDeposit;
    }
    
    // Methods with appropriate variable scoping
    public void deposit(double amount) {
        // LOCAL: Temporary validation
        if (amount <= 0) {
            System.out.println("Deposit amount must be positive");
            return;
        }
        double oldBalance = this.balance; // Local copy
        this.balance += amount;
        logTransaction("DEPOSIT", amount, oldBalance, this.balance);
    }
    
    public boolean withdraw(double amount) {
        // LOCAL: Check multiple conditions
        boolean hasSufficientFunds = this.balance >= amount;
        boolean meetsMinimum = (this.balance - amount) >= MINIMUM_BALANCE;
        
        if (!hasSufficientFunds) {
            System.out.println("Insufficient funds");
            return false;
        }
        
        if (!meetsMinimum) {
            System.out.println("Would violate minimum balance requirement");
            return false;
        }
        
        double oldBalance = this.balance;
        this.balance -= amount;
        logTransaction("WITHDRAWAL", amount, oldBalance, this.balance);
        return true;
    }
    
    private void logTransaction(String type, double amount, 
                               double oldBalance, double newBalance) {
        // LOCAL: Formatting variables
        String timestamp = java.time.LocalDateTime.now().toString();
        String formattedAmount = String.format("$%.2f", amount);
        
        System.out.printf("[%s] %s: %s | Balance: $%.2f → $%.2f%n",
                         timestamp, type, formattedAmount, 
                         oldBalance, newBalance);
    }
    
    // STATIC METHOD: Uses only class constants and parameters
    public static double calculateInterest(double principal, 
                                         double rate, int years) {
        // LOCAL: Calculation variables
        double interest = principal * rate * years;
        return principal + interest;
    }
}
```

**Programming Tasks:**
1. Identify which variables should be class vs instance vs local
2. Create methods with proper parameter passing
3. Demonstrate variable shadowing and how to avoid it
4. Implement transaction history using appropriate data structures
5. Add validation methods with local error checking

**Challenge:** Create a `Bank` class that manages multiple accounts, demonstrating when to use static vs instance variables and methods.
