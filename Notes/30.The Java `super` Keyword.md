# The Java `super` Keyword

## Introduction to `super`
The `super` keyword in Java is used to refer to the immediate parent class of an object. It's a fundamental concept in inheritance, allowing child classes (subclasses) to interact with their parent classes (superclasses).

## When to Use `super`
The `super` keyword has two primary use cases:

1. **Calling Parent Class Constructors:** When a child class needs to initialize the attributes inherited from its parent, it uses `super()` to call the parent's constructor. This is crucial because the parent class's constructor is responsible for setting up the parent's part of the object.

2. **Method Overriding:** While this material focuses on constructors, `super` can also be used within overridden methods in a child class to call the method of the same name from the parent class. This is useful when you want to extend the parent's behavior rather than completely replace it.

## `super` in Constructors

### The Problem: Uninitialized Parent Attributes
When a class inherits from another, it gains all the non-private attributes and methods of the parent. However, if the parent class has a constructor that requires arguments (i.e., it's not a default no-argument constructor), the child class must explicitly call that parent constructor to initialize the inherited attributes. If it doesn't, Java will produce a compilation error, often indicating "There is no default (no-argument) constructor available in the parent class."

### The Solution: Using `super()`
To resolve this, the child class's constructor must include a call to `super()` as its first statement. This `super()` call passes the necessary arguments to the parent class's constructor, ensuring that the inherited attributes are properly initialized.

## Example: Person, Student, and Employee
Let's walk through the provided example to illustrate this.

### 1. The Person Class (Parent/Superclass)
This is the base class. It has first and last name attributes and a constructor to initialize them. It also has a `showName` method.

```java
public class Person {
    String first;
    String last;

    Person(String first, String last) {
        this.first = first;
        this.last = last;
    }

    void showName() {
        System.out.println(this.first + " " + this.last);
    }
}
```

### 2. The Student Class (Child/Subclass of Person)
The Student class inherits from Person and adds a gpa attribute.

**Constructor without `super()` (will cause an error):** If we tried to initialize first and last directly within the Student constructor like this:
```java
// This is INCORRECT and will cause a compilation error
Student(String first, String last, double gpa) {
    this.first = first; // Inherited from Person
    this.last = last;   // Inherited from Person
    this.gpa = gpa;     // Student's own attribute
}
```
We would get an error because the Person constructor (`Person(String first, String last)`) needs to be called to initialize `this.first` and `this.last`.

**Constructor with `super()`:** The correct way is to call the Person constructor using `super()`:

```java
public class Student extends Person {
    double gpa;

    Student(String first, String last, double gpa) {
        super(first, last); // Calls the Person constructor
        this.gpa = gpa;
    }

    void showGPA() {
        System.out.println(this.first + "'s gpa is: " + this.gpa);
    }
}
```

Here, `super(first, last);` tells Java to execute the Person constructor, passing the first and last names. Only after the Person constructor finishes its work can the rest of the Student constructor (initializing `this.gpa`) proceed.

### 3. The Employee Class (Child/Subclass of Person)
Similarly, the Employee class inherits from Person and adds a salary attribute.

**Constructor with `super()`:**
```java
public class Employee extends Person {
    int salary;

    Employee(String first, String last, int salary) {
        super(first, last); // Calls the Person constructor
        this.salary = salary;
    }

    void showSalary() {
        System.out.println(this.first + "'s salary is $" + this.salary);
    }
}
```

Again, `super(first, last);` is essential for initializing the first and last names inherited from the Person class.

## `super` and Method Overriding
While not the main focus of this material, it's important to know that `super` can also be used to call a method from the parent class within a child class that has overridden that method.

For example, if Person had a more complex `displayInfo()` method, a Student class could override it and still call the parent's `displayInfo()` using `super.displayInfo()`.

```java
// Hypothetical example if Person had displayInfo()
// public class Person {
//     void displayInfo() {
//         System.out.println("This is a person.");
//     }
// }

// public class Student extends Person {
//     @Override
//     void displayInfo() {
//         super.displayInfo(); // Calls Person's displayInfo()
//         System.out.println("And this student has a GPA.");
//     }
// }
```

## Key Takeaways
- `super` refers to the immediate parent class.
- It is primarily used in constructors to call the parent's constructor.
- This is necessary when the parent's constructor requires arguments, ensuring inherited attributes are initialized.
- The `super()` call must be the first statement in the child constructor.
- `super` can also be used to call overridden methods from the parent class.

## Detailed Uses of `super` Keyword

### 1. Calling Parent Class Constructor
```java
class Parent {
    int x;
    
    Parent(int x) {
        this.x = x;
        System.out.println("Parent constructor: x = " + x);
    }
}

class Child extends Parent {
    int y;
    
    Child(int x, int y) {
        super(x); // Must be first statement
        this.y = y;
        System.out.println("Child constructor: y = " + y);
    }
}

// Usage
Child obj = new Child(10, 20);
// Output:
// Parent constructor: x = 10
// Child constructor: y = 20
```

### 2. Accessing Parent Class Fields
```java
class Parent {
    String message = "Hello from Parent";
}

class Child extends Parent {
    String message = "Hello from Child";
    
    void display() {
        System.out.println(super.message); // Parent's message
        System.out.println(this.message);  // Child's message
        System.out.println(message);       // Child's message (implicit this)
    }
}

// Usage
Child obj = new Child();
obj.display();
// Output:
// Hello from Parent
// Hello from Child
// Hello from Child
```

### 3. Calling Parent Class Methods
```java
class Parent {
    void display() {
        System.out.println("Parent's display method");
    }
}

class Child extends Parent {
    @Override
    void display() {
        super.display(); // Call parent's display method
        System.out.println("Child's display method");
    }
    
    void show() {
        super.display(); // Can call parent method from any method
    }
}

// Usage
Child obj = new Child();
obj.display();
// Output:
// Parent's display method
// Child's display method
```

### 4. Constructor Chaining with `super()`
```java
class Grandparent {
    Grandparent() {
        System.out.println("Grandparent constructor");
    }
}

class Parent extends Grandparent {
    Parent() {
        // Implicit super() call to Grandparent
        System.out.println("Parent constructor");
    }
}

class Child extends Parent {
    Child() {
        // Implicit super() call to Parent
        System.out.println("Child constructor");
    }
}

// Usage
Child obj = new Child();
// Output:
// Grandparent constructor
// Parent constructor
// Child constructor
```

## Rules for Using `super()`

### 1. Must be First Statement
```java
class Parent {
    Parent(int x) { /* ... */ }
}

class Child extends Parent {
    Child(int x, int y) {
        // super(x); // Must come first
        this.y = y;   // ERROR if placed before super()
        super(x);     // ERROR: super() must be first statement
    }
}
```

### 2. Implicit `super()` Call
```java
class Parent {
    Parent() {
        System.out.println("Parent constructor");
    }
}

class Child extends Parent {
    Child() {
        // super(); is implicitly called here
        System.out.println("Child constructor");
    }
}

// Usage
new Child();
// Output:
// Parent constructor
// Child constructor
```

### 3. No Default Constructor Scenario
```java
class Parent {
    Parent(int x) { /* ... */ }
    // No default constructor Parent()
}

class Child extends Parent {
    Child() {
        // ERROR: Implicit super() Parent() is undefined
        // Must explicitly call super(x)
    }
    
    Child(int x) {
        super(x); // OK
    }
}
```

## Practical Examples

### Example 1: Vehicle Hierarchy
```java
class Vehicle {
    String brand;
    int year;
    
    Vehicle(String brand, int year) {
        this.brand = brand;
        this.year = year;
    }
    
    void display() {
        System.out.println("Brand: " + brand + ", Year: " + year);
    }
}

class Car extends Vehicle {
    int doors;
    
    Car(String brand, int year, int doors) {
        super(brand, year); // Initialize Vehicle part
        this.doors = doors;
    }
    
    @Override
    void display() {
        super.display(); // Call Vehicle's display
        System.out.println("Doors: " + doors);
    }
}
```

### Example 2: Employee Management
```java
class Person {
    String name;
    int age;
    
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    void introduce() {
        System.out.println("I am " + name + ", " + age + " years old.");
    }
}

class Employee extends Person {
    String employeeId;
    double salary;
    
    Employee(String name, int age, String employeeId, double salary) {
        super(name, age); // Initialize Person attributes
        this.employeeId = employeeId;
        this.salary = salary;
    }
    
    @Override
    void introduce() {
        super.introduce(); // Person's introduction
        System.out.println("My employee ID is " + employeeId);
    }
    
    void showSalary() {
        System.out.println(name + "'s salary: $" + salary);
    }
}
```

### Example 3: Banking System
```java
class Account {
    String accountNumber;
    double balance;
    
    Account(String accountNumber, double balance) {
        this.accountNumber = accountNumber;
        this.balance = balance;
    }
    
    void deposit(double amount) {
        balance += amount;
        System.out.println("Deposited: $" + amount);
    }
    
    void displayBalance() {
        System.out.println("Account " + accountNumber + 
                          " balance: $" + balance);
    }
}

class SavingsAccount extends Account {
    double interestRate;
    
    SavingsAccount(String accountNumber, double balance, double interestRate) {
        super(accountNumber, balance);
        this.interestRate = interestRate;
    }
    
    void addInterest() {
        double interest = balance * interestRate / 100;
        super.deposit(interest); // Use parent's deposit method
        System.out.println("Interest added: $" + interest);
    }
    
    @Override
    void displayBalance() {
        super.displayBalance();
        System.out.println("Interest rate: " + interestRate + "%");
    }
}
```

## Common Mistakes and Solutions

### Mistake 1: Forgetting `super()` Call
```java
class Parent {
    Parent(int x) { /* ... */ }
}

class Child extends Parent {
    Child() {
        // ERROR: No default constructor in Parent
        // Solution: Add super(x) call
    }
}
```

### Mistake 2: `super()` Not First Statement
```java
class Child extends Parent {
    Child(int x, int y) {
        this.y = y;    // ERROR
        super(x);      // Must be first
    }
}
```

### Mistake 3: Circular Constructor Calls
```java
class Parent {
    Parent() {
        this(10); // Calls another constructor
    }
    
    Parent(int x) {
        super(); // Calls Object constructor
    }
}
```

## Best Practices

### 1. Explicit `super()` Calls
```java
// Even when not required, explicit super() can improve readability
class Child extends Parent {
    Child() {
        super(); // Explicit even though implicit would work
    }
}
```

### 2. Parameter Validation
```java
class Parent {
    Parent(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Name cannot be empty");
        }
        // ...
    }
}

class Child extends Parent {
    Child(String name, int value) {
        super(name); // Parent validates name
        // Child validates its own parameters
        if (value < 0) {
            throw new IllegalArgumentException("Value cannot be negative");
        }
    }
}
```

### 3. Constructor Chaining
```java
class Parent {
    Parent() {
        this("Default"); // Chain to another constructor
    }
    
    Parent(String name) {
        // Initialize
    }
}

class Child extends Parent {
    Child() {
        super(); // Calls Parent() which chains to Parent(String)
    }
}
```

## Advanced Usage

### 1. Using `super` with Interfaces
```java
interface A {
    default void show() {
        System.out.println("Interface A");
    }
}

interface B {
    default void show() {
        System.out.println("Interface B");
    }
}

class C implements A, B {
    @Override
    public void show() {
        A.super.show(); // Call A's default method
        B.super.show(); // Call B's default method
    }
}
```

### 2. Generic Classes with `super`
```java
class Parent<T> {
    T value;
    
    Parent(T value) {
        this.value = value;
    }
}

class Child<T> extends Parent<T> {
    Child(T value) {
        super(value); // Type-safe constructor call
    }
}
```

### 3. Abstract Classes with `super`
```java
abstract class Shape {
    String color;
    
    Shape(String color) {
        this.color = color;
    }
    
    abstract double area();
}

class Circle extends Shape {
    double radius;
    
    Circle(String color, double radius) {
        super(color); // Must call abstract class constructor
        this.radius = radius;
    }
    
    @Override
    double area() {
        return Math.PI * radius * radius;
    }
}
```

---

## Activities

### Activity 1: Animal Hierarchy with Constructors
Create an animal hierarchy:
1. **Base class:** `Animal` with name, age, and sound attributes
2. **Derived classes:** `Dog`, `Cat`, `Bird` with additional attributes
3. **Requirements:**
   - Use `super()` in all derived class constructors
   - Add at least 2 unique attributes to each derived class
   - Override `makeSound()` method in each derived class
   - Use `super` to call parent method in overridden methods
4. Create objects and demonstrate constructor chaining

### Activity 2: E-commerce Product System
Create a product hierarchy:
1. **Base class:** `Product` with productId, name, price, quantity
2. **Derived classes:**
   - `Electronics`: warrantyPeriod, brand
   - `Clothing`: size, material, color
   - `Books`: author, ISBN, publisher
3. **Requirements:**
   - All derived classes must use `super()` in constructors
   - Override `displayInfo()` method in each class
   - Use `super.displayInfo()` to show common product info
   - Add methods specific to each product type
4. Create an array of different product types and display their info

### Activity 3: University Management System
Create a university management system:
1. **Base class:** `UniversityMember` with name, id, email
2. **Derived classes:**
   - `Student`: major, gpa, yearLevel
   - `Professor`: department, officeNumber, coursesTeaching[]
   - `Staff`: position, department, salary
3. **Requirements:**
   - Implement constructor chaining with `super()`
   - Create methods that use `super` to call parent methods
   - Add validation in constructors
   - Create a method that accepts `UniversityMember` array and processes all members
4. Demonstrate polymorphism with base class references
